#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

// include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

/* automatically generated by rust-bindgen 0.69.2 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const JXL_TRUE: u32 = 1;
pub const JXL_FALSE: u32 = 0;
pub const JXL_PARALLEL_RET_RUNNER_ERROR: i32 = -1;
pub const JPEGXL_MAJOR_VERSION: u32 = 0;
pub const JPEGXL_MINOR_VERSION: u32 = 0;
pub const JPEGXL_PATCH_VERSION: u32 = 0;
pub const _MAX_ITOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: u32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: u32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: u32 = 65;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const RAND_MAX: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _MAX_ENV: u32 = 32767;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[doc = " Tristimulus RGB"]
pub const JxlColorSpace_JXL_COLOR_SPACE_RGB: JxlColorSpace = 0;
#[doc = " Luminance based, the primaries in JxlColorEncoding must be ignored. This\n value implies that num_color_channels in JxlBasicInfo is 1, any other value\n implies num_color_channels is 3."]
pub const JxlColorSpace_JXL_COLOR_SPACE_GRAY: JxlColorSpace = 1;
#[doc = " XYB (opsin) color space"]
pub const JxlColorSpace_JXL_COLOR_SPACE_XYB: JxlColorSpace = 2;
#[doc = " None of the other table entries describe the color space appropriately"]
pub const JxlColorSpace_JXL_COLOR_SPACE_UNKNOWN: JxlColorSpace = 3;
#[doc = " Color space of the image data."]
pub type JxlColorSpace = ::std::os::raw::c_int;
#[doc = " CIE Standard Illuminant D65: 0.3127, 0.3290"]
pub const JxlWhitePoint_JXL_WHITE_POINT_D65: JxlWhitePoint = 1;
#[doc = " White point must be read from the JxlColorEncoding white_point field, or\n as ICC profile. This enum value is not an exact match of the corresponding\n CICP value."]
pub const JxlWhitePoint_JXL_WHITE_POINT_CUSTOM: JxlWhitePoint = 2;
#[doc = " CIE Standard Illuminant E (equal-energy): 1/3, 1/3"]
pub const JxlWhitePoint_JXL_WHITE_POINT_E: JxlWhitePoint = 10;
#[doc = " DCI-P3 from SMPTE RP 431-2: 0.314, 0.351"]
pub const JxlWhitePoint_JXL_WHITE_POINT_DCI: JxlWhitePoint = 11;
#[doc = " Built-in whitepoints for color encoding. When decoding, the numerical xy\n whitepoint value can be read from the JxlColorEncoding white_point field\n regardless of the enum value. When encoding, enum values except\n JXL_WHITE_POINT_CUSTOM override the numerical fields. Some enum values match\n a subset of CICP (Rec. ITU-T H.273 | ISO/IEC 23091-2:2019(E)), however the\n white point and RGB primaries are separate enums here."]
pub type JxlWhitePoint = ::std::os::raw::c_int;
#[doc = " The CIE xy values of the red, green and blue primaries are: 0.639998686,\n0.330010138; 0.300003784, 0.600003357; 0.150002046, 0.059997204"]
pub const JxlPrimaries_JXL_PRIMARIES_SRGB: JxlPrimaries = 1;
#[doc = " Primaries must be read from the JxlColorEncoding primaries_red_xy,\n primaries_green_xy and primaries_blue_xy fields, or as ICC profile. This\n enum value is not an exact match of the corresponding CICP value."]
pub const JxlPrimaries_JXL_PRIMARIES_CUSTOM: JxlPrimaries = 2;
#[doc = " As specified in Rec. ITU-R BT.2100-1"]
pub const JxlPrimaries_JXL_PRIMARIES_2100: JxlPrimaries = 9;
#[doc = " As specified in SMPTE RP 431-2"]
pub const JxlPrimaries_JXL_PRIMARIES_P3: JxlPrimaries = 11;
#[doc = " Built-in primaries for color encoding. When decoding, the primaries can be\n read from the JxlColorEncoding primaries_red_xy, primaries_green_xy and\n primaries_blue_xy fields regardless of the enum value. When encoding, the\n enum values except JXL_PRIMARIES_CUSTOM override the numerical fields. Some\n enum values match a subset of CICP (Rec. ITU-T H.273 | ISO/IEC\n 23091-2:2019(E)), however the white point and RGB primaries are separate\n enums here."]
pub type JxlPrimaries = ::std::os::raw::c_int;
#[doc = " As specified in SMPTE RP 431-2"]
pub const JxlTransferFunction_JXL_TRANSFER_FUNCTION_709: JxlTransferFunction = 1;
#[doc = " None of the other table entries describe the transfer function."]
pub const JxlTransferFunction_JXL_TRANSFER_FUNCTION_UNKNOWN: JxlTransferFunction = 2;
#[doc = " The gamma exponent is 1"]
pub const JxlTransferFunction_JXL_TRANSFER_FUNCTION_LINEAR: JxlTransferFunction = 8;
#[doc = " As specified in IEC 61966-2-1 sRGB"]
pub const JxlTransferFunction_JXL_TRANSFER_FUNCTION_SRGB: JxlTransferFunction = 13;
#[doc = " As specified in SMPTE ST 2084"]
pub const JxlTransferFunction_JXL_TRANSFER_FUNCTION_PQ: JxlTransferFunction = 16;
#[doc = " As specified in SMPTE ST 428-1"]
pub const JxlTransferFunction_JXL_TRANSFER_FUNCTION_DCI: JxlTransferFunction = 17;
#[doc = " As specified in Rec. ITU-R BT.2100-1 (HLG)"]
pub const JxlTransferFunction_JXL_TRANSFER_FUNCTION_HLG: JxlTransferFunction = 18;
#[doc = " Transfer function follows power law given by the gamma value in\nJxlColorEncoding. Not a CICP value."]
pub const JxlTransferFunction_JXL_TRANSFER_FUNCTION_GAMMA: JxlTransferFunction = 65535;
#[doc = " Built-in transfer functions for color encoding. Enum values match a subset\n of CICP (Rec. ITU-T H.273 | ISO/IEC 23091-2:2019(E)) unless specified\n otherwise."]
pub type JxlTransferFunction = ::std::os::raw::c_int;
#[doc = " vendor-specific"]
pub const JxlRenderingIntent_JXL_RENDERING_INTENT_PERCEPTUAL: JxlRenderingIntent = 0;
#[doc = " media-relative"]
pub const JxlRenderingIntent_JXL_RENDERING_INTENT_RELATIVE: JxlRenderingIntent = 1;
#[doc = " vendor-specific"]
pub const JxlRenderingIntent_JXL_RENDERING_INTENT_SATURATION: JxlRenderingIntent = 2;
#[doc = " ICC-absolute"]
pub const JxlRenderingIntent_JXL_RENDERING_INTENT_ABSOLUTE: JxlRenderingIntent = 3;
#[doc = " Renderig intent for color encoding, as specified in ISO 15076-1:2010"]
pub type JxlRenderingIntent = ::std::os::raw::c_int;
#[doc = " Color encoding of the image as structured information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlColorEncoding {
    #[doc = " Color space of the image data."]
    pub color_space: JxlColorSpace,
    #[doc = " Built-in white point. If this value is JXL_WHITE_POINT_CUSTOM, must\n use the numerical whitepoint values from white_point_xy."]
    pub white_point: JxlWhitePoint,
    #[doc = " Numerical whitepoint values in CIE xy space."]
    pub white_point_xy: [f64; 2usize],
    #[doc = " Built-in RGB primaries. If this value is JXL_PRIMARIES_CUSTOM, must\n use the numerical primaries values below. This field and the custom values\n below are unused and must be ignored if the color space is\n JXL_COLOR_SPACE_GRAY or JXL_COLOR_SPACE_XYB."]
    pub primaries: JxlPrimaries,
    #[doc = " Numerical red primary values in CIE xy space."]
    pub primaries_red_xy: [f64; 2usize],
    #[doc = " Numerical green primary values in CIE xy space."]
    pub primaries_green_xy: [f64; 2usize],
    #[doc = " Numerical blue primary values in CIE xy space."]
    pub primaries_blue_xy: [f64; 2usize],
    #[doc = " Transfer function if have_gamma is 0"]
    pub transfer_function: JxlTransferFunction,
    #[doc = " Gamma value used when transfer_function is JXL_TRANSFER_FUNCTION_GAMMA"]
    pub gamma: f64,
    #[doc = " Rendering intent defined for the color profile."]
    pub rendering_intent: JxlRenderingIntent,
}
#[test]
fn bindgen_test_layout_JxlColorEncoding() {
    const UNINIT: ::std::mem::MaybeUninit<JxlColorEncoding> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JxlColorEncoding>(),
        104usize,
        concat!("Size of: ", stringify!(JxlColorEncoding))
    );
    assert_eq!(
        ::std::mem::align_of::<JxlColorEncoding>(),
        8usize,
        concat!("Alignment of ", stringify!(JxlColorEncoding))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_space) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlColorEncoding),
        "::",
        stringify!(color_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).white_point) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlColorEncoding),
        "::",
        stringify!(white_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).white_point_xy) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlColorEncoding),
        "::",
        stringify!(white_point_xy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).primaries) as usize - ptr as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlColorEncoding),
        "::",
        stringify!(primaries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).primaries_red_xy) as usize - ptr as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlColorEncoding),
        "::",
        stringify!(primaries_red_xy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).primaries_green_xy) as usize - ptr as usize },
        48usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlColorEncoding),
        "::",
        stringify!(primaries_green_xy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).primaries_blue_xy) as usize - ptr as usize },
        64usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlColorEncoding),
        "::",
        stringify!(primaries_blue_xy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transfer_function) as usize - ptr as usize },
        80usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlColorEncoding),
        "::",
        stringify!(transfer_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gamma) as usize - ptr as usize },
        88usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlColorEncoding),
        "::",
        stringify!(gamma)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rendering_intent) as usize - ptr as usize },
        96usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlColorEncoding),
        "::",
        stringify!(rendering_intent)
        )
    );
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_data_public> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_pctype) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(__crt_locale_data_public),
        "::",
        stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_mb_cur_max) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(__crt_locale_data_public),
        "::",
        stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_lc_codepage) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(__crt_locale_data_public),
        "::",
        stringify!(_locale_lc_codepage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_pointers> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(__crt_locale_pointers),
        "::",
        stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(__crt_locale_pointers),
        "::",
        stringify!(mbcinfo)
        )
    );
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    const UNINIT: ::std::mem::MaybeUninit<_Mbstatet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Wchar) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_Mbstatet),
        "::",
        stringify!(_Wchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Byte) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(_Mbstatet),
        "::",
        stringify!(_Byte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._State) as usize - ptr as usize },
        6usize,
        concat!(
        "Offset of field: ",
        stringify!(_Mbstatet),
        "::",
        stringify!(_State)
        )
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __threadid() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __threadhandle() -> usize;
}
#[doc = " Use 32-bit single-precision floating point values, with range 0.0-1.0\n (within gamut, may go outside this range for wide color gamut). Floating\n point output, either JXL_TYPE_FLOAT or JXL_TYPE_FLOAT16, is recommended\n for HDR and wide gamut images when color profile conversion is required."]
pub const JxlDataType_JXL_TYPE_FLOAT: JxlDataType = 0;
#[doc = " Use type uint8_t. May clip wide color gamut data."]
pub const JxlDataType_JXL_TYPE_UINT8: JxlDataType = 2;
#[doc = " Use type uint16_t. May clip wide color gamut data."]
pub const JxlDataType_JXL_TYPE_UINT16: JxlDataType = 3;
#[doc = " Use 16-bit IEEE 754 half-precision floating point values"]
pub const JxlDataType_JXL_TYPE_FLOAT16: JxlDataType = 5;
#[doc = " Data type for the sample values per channel per pixel."]
pub type JxlDataType = ::std::os::raw::c_int;
#[doc = " Use the endianness of the system, either little endian or big endian,\n without forcing either specific endianness. Do not use if pixel data\n should be exported to a well defined format."]
pub const JxlEndianness_JXL_NATIVE_ENDIAN: JxlEndianness = 0;
#[doc = " Force little endian"]
pub const JxlEndianness_JXL_LITTLE_ENDIAN: JxlEndianness = 1;
#[doc = " Force big endian"]
pub const JxlEndianness_JXL_BIG_ENDIAN: JxlEndianness = 2;
#[doc = " Ordering of multi-byte data."]
pub type JxlEndianness = ::std::os::raw::c_int;
#[doc = " Data type for the sample values per channel per pixel for the output buffer\n for pixels. This is not necessarily the same as the data type encoded in the\n codestream. The channels are interleaved per pixel. The pixels are\n organized row by row, left to right, top to bottom.\n TODO(lode): support different channel orders if needed (RGB, BGR, ...)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlPixelFormat {
    #[doc = " Amount of channels available in a pixel buffer.\n 1: single-channel data, e.g. grayscale or a single extra channel\n 2: single-channel + alpha\n 3: trichromatic, e.g. RGB\n 4: trichromatic + alpha\n TODO(lode): this needs finetuning. It is not yet defined how the user\n chooses output color space. CMYK+alpha needs 5 channels."]
    pub num_channels: u32,
    #[doc = " Data type of each channel."]
    pub data_type: JxlDataType,
    #[doc = " Whether multi-byte data types are represented in big endian or little\n endian format. This applies to JXL_TYPE_UINT16, JXL_TYPE_UINT32\n and JXL_TYPE_FLOAT."]
    pub endianness: JxlEndianness,
    #[doc = " Align scanlines to a multiple of align bytes, or 0 to require no\n alignment at all (which has the same effect as value 1)"]
    pub align: usize,
}
#[test]
fn bindgen_test_layout_JxlPixelFormat() {
    const UNINIT: ::std::mem::MaybeUninit<JxlPixelFormat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JxlPixelFormat>(),
        24usize,
        concat!("Size of: ", stringify!(JxlPixelFormat))
    );
    assert_eq!(
        ::std::mem::align_of::<JxlPixelFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(JxlPixelFormat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_channels) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlPixelFormat),
        "::",
        stringify!(num_channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_type) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlPixelFormat),
        "::",
        stringify!(data_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endianness) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlPixelFormat),
        "::",
        stringify!(endianness)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).align) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlPixelFormat),
        "::",
        stringify!(align)
        )
    );
}
#[doc = " This is the default setting, where the encoder expects the input pixels\n to use the full range of the pixel format data type (e.g. for UINT16, the\n input range is 0 .. 65535 and the value 65535 is mapped to 1.0 when\n converting to float), and the decoder uses the full range to output\n pixels. If the bit depth in the basic info is different from this, the\n encoder expects the values to be rescaled accordingly (e.g. multiplied by\n 65535/4095 for a 12-bit image using UINT16 input data type)."]
pub const JxlBitDepthType_JXL_BIT_DEPTH_FROM_PIXEL_FORMAT: JxlBitDepthType = 0;
#[doc = " If this setting is selected, the encoder expects the input pixels to be\n in the range defined by the bits_per_sample value of the basic info (e.g.\n for 12-bit images using UINT16 input data types, the allowed range is\n 0 .. 4095 and the value 4095 is mapped to 1.0 when converting to float),\n and the decoder outputs pixels in this range."]
pub const JxlBitDepthType_JXL_BIT_DEPTH_FROM_CODESTREAM: JxlBitDepthType = 1;
#[doc = " This setting can only be used in the decoder to select a custom range for\n pixel output"]
pub const JxlBitDepthType_JXL_BIT_DEPTH_CUSTOM: JxlBitDepthType = 2;
#[doc = " Settings for the interpretation of UINT input and output buffers.\n  (buffers using a FLOAT data type are not affected by this)"]
pub type JxlBitDepthType = ::std::os::raw::c_int;
#[doc = " Data type for describing the interpretation of the input and output buffers\n in terms of the range of allowed input and output pixel values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlBitDepth {
    #[doc = " Bit depth setting, see comment on @ref JxlBitDepthType"]
    pub type_: JxlBitDepthType,
    #[doc = " Custom bits per sample"]
    pub bits_per_sample: u32,
    #[doc = " Custom exponent bits per sample"]
    pub exponent_bits_per_sample: u32,
}
#[test]
fn bindgen_test_layout_JxlBitDepth() {
    const UNINIT: ::std::mem::MaybeUninit<JxlBitDepth> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JxlBitDepth>(),
        12usize,
        concat!("Size of: ", stringify!(JxlBitDepth))
    );
    assert_eq!(
        ::std::mem::align_of::<JxlBitDepth>(),
        4usize,
        concat!("Alignment of ", stringify!(JxlBitDepth))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBitDepth),
        "::",
        stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_per_sample) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBitDepth),
        "::",
        stringify!(bits_per_sample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exponent_bits_per_sample) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBitDepth),
        "::",
        stringify!(exponent_bits_per_sample)
        )
    );
}
#[doc = " Data type holding the 4-character type name of an ISOBMFF box."]
pub type JxlBoxType = [::std::os::raw::c_char; 4usize];
#[doc = " Parses an ICC profile and populates @p c and @p cmyk with the data.\n\n @param user_data JxlCmsInterface::set_fields_data passed as-is.\n @param icc_data the ICC data to parse.\n @param icc_size how many bytes of icc_data are valid.\n @param c a JxlColorEncoding to populate if applicable.\n @param cmyk a boolean to set to whether the colorspace is a CMYK colorspace.\n @return Whether the relevant fields in @p c were successfully populated."]
pub type jpegxl_cms_set_fields_from_icc_func = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        icc_data: *const u8,
        icc_size: usize,
        c: *mut JxlColorEncoding,
        cmyk: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Represents an input or output colorspace to a color transform, as a\n serialized ICC profile."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlColorProfile {
    pub icc: JxlColorProfile__bindgen_ty_1,
    #[doc = " Structured representation of the colorspace, if applicable. If all fields\n are different from their \"unknown\" value, then this is equivalent to the\n ICC representation of the colorspace. If some are \"unknown\", those that are\n not are still valid and can still be used on their own if they are useful."]
    pub color_encoding: JxlColorEncoding,
    #[doc = " Number of components per pixel. This can be deduced from the other\n representations of the colorspace but is provided for convenience and\n validation."]
    pub num_channels: usize,
}
#[doc = " The serialized ICC profile. This is guaranteed to be present and valid."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlColorProfile__bindgen_ty_1 {
    pub data: *const u8,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_JxlColorProfile__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<JxlColorProfile__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JxlColorProfile__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(JxlColorProfile__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<JxlColorProfile__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(JxlColorProfile__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlColorProfile__bindgen_ty_1),
        "::",
        stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlColorProfile__bindgen_ty_1),
        "::",
        stringify!(size)
        )
    );
}
#[test]
fn bindgen_test_layout_JxlColorProfile() {
    const UNINIT: ::std::mem::MaybeUninit<JxlColorProfile> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JxlColorProfile>(),
        128usize,
        concat!("Size of: ", stringify!(JxlColorProfile))
    );
    assert_eq!(
        ::std::mem::align_of::<JxlColorProfile>(),
        8usize,
        concat!("Alignment of ", stringify!(JxlColorProfile))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).icc) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlColorProfile),
        "::",
        stringify!(icc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_encoding) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlColorProfile),
        "::",
        stringify!(color_encoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_channels) as usize - ptr as usize },
        120usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlColorProfile),
        "::",
        stringify!(num_channels)
        )
    );
}
#[doc = " Allocates and returns the data needed for @p num_threads parallel transforms\n from the @p input colorspace to @p output, with up to @p pixels_per_thread\n pixels to transform per call to JxlCmsInterface::run. @p init_data comes\n directly from the JxlCmsInterface instance. Since @c run only receives the\n data returned by @c init, a reference to @p init_data should be kept there\n if access to it is desired in @c run. Likewise for JxlCmsInterface::destroy.\n\n The ICC data in @p input and @p output is guaranteed to outlive the @c init /\n @c run / @c destroy cycle.\n\n @param init_data JxlCmsInterface::init_data passed as-is.\n @param num_threads the maximum number of threads from which\n        JxlCmsInterface::run will be called.\n @param pixels_per_thread the maximum number of pixels that each call to\n        JxlCmsInterface::run will have to transform.\n @param input_profile the input colorspace for the transform.\n @param output_profile the colorspace to which JxlCmsInterface::run should\n        convert the input data.\n @param intensity_target for colorspaces where luminance is relative\n        (essentially: not PQ), indicates the luminance at which (1, 1, 1) will\n        be displayed. This is useful for conversions between PQ and a relative\n        luminance colorspace, in either direction: @p intensity_target cd/m²\n        in PQ should map to and from (1, 1, 1) in the relative one.\\n\n        It is also used for conversions to and from HLG, as it is\n        scene-referred while other colorspaces are assumed to be\n        display-referred. That is, conversions from HLG should apply the OOTF\n        for a peak display luminance of @p intensity_target, and conversions\n        to HLG should undo it. The OOTF is a gamma function applied to the\n        luminance channel (https://www.itu.int/rec/R-REC-BT.2100-2-201807-I\n        page 7), with the gamma value computed as\n        <tt>1.2 * 1.111^log2(intensity_target / 1000)</tt> (footnote 2 page 8\n        of the same document).\n @return The data needed for the transform, or @c NULL in case of failure.\n         This will be passed to the other functions as @c user_data."]
pub type jpegxl_cms_init_func = ::std::option::Option<
    unsafe extern "C" fn(
        init_data: *mut ::std::os::raw::c_void,
        num_threads: usize,
        pixels_per_thread: usize,
        input_profile: *const JxlColorProfile,
        output_profile: *const JxlColorProfile,
        intensity_target: f32,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Returns a buffer that can be used by callers of the interface to store the\n input of the conversion or read its result, if they pass it as the input or\n output of the @c run function.\n @param user_data the data returned by @c init.\n @param thread the index of the thread for which to return a buffer.\n @return A buffer that can be used by the caller for passing to @c run."]
pub type jpegxl_cms_get_buffer_func = ::std::option::Option<
    unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, thread: usize) -> *mut f32,
>;
#[doc = " Executes one transform and returns true on success or false on error. It\n must be possible to call this from different threads with different values\n for @p thread, all between 0 (inclusive) and the value of @p num_threads\n passed to @c init (exclusive). It is allowed to implement this by locking\n such that the transforms are essentially performed sequentially, if such a\n performance profile is acceptable. @p user_data is the data returned by\n @c init.\n The buffers each contain @p num_pixels × @c num_channels interleaved floating\n point (0..1) samples where @c num_channels is the number of color channels of\n their respective color profiles. It is guaranteed that the only case in which\n they might overlap is if the output has fewer channels than the input, in\n which case the pointers may be identical.\n For CMYK data, 0 represents the maximum amount of ink while 1 represents no\n ink.\n @param user_data the data returned by @c init.\n @param thread the index of the thread from which the function is being\n        called.\n @param input_buffer the buffer containing the pixel data to be transformed.\n @param output_buffer the buffer receiving the transformed pixel data.\n @param num_pixels the number of pixels to transform from @p input to\n @p output.\n @return JXL_TRUE on success, JXL_FALSE on failure."]
pub type jpegxl_cms_run_func = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        thread: usize,
        input_buffer: *const f32,
        output_buffer: *mut f32,
        num_pixels: usize,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Performs the necessary clean-up and frees the memory allocated for user\n data."]
pub type jpegxl_cms_destroy_func =
::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[doc = " Interface for performing colorspace transforms. The @c init function can be\n called several times to instantiate several transforms, including before\n other transforms have been destroyed.\n\n The call sequence for a given colorspace transform could look like the\n following:\n @dot\n digraph calls {\n   newrank = true\n   node [shape = box, fontname = monospace]\n   init [label = \"user_data <- init(\\l\\\n     init_data = data,\\l\\\n     num_threads = 3,\\l\\\n     pixels_per_thread = 20,\\l\\\n     input = (sRGB, 3 channels),\\l\\\n     output = (Display-P3, 3 channels),\\l\\\n     intensity_target = 255\\l\\\n   )\\l\"]\n   subgraph cluster_0 {\n   color = lightgrey\n   label = \"thread 1\"\n   labeljust = \"c\"\n   run_1_1 [label = \"run(\\l\\\n     user_data,\\l\\\n     thread = 1,\\l\\\n     input = in[0],\\l\\\n     output = out[0],\\l\\\n     num_pixels = 20\\l\\\n   )\\l\"]\n   run_1_2 [label = \"run(\\l\\\n     user_data,\\l\\\n     thread = 1,\\l\\\n     input = in[3],\\l\\\n     output = out[3],\\l\\\n     num_pixels = 20\\l\\\n   )\\l\"]\n   }\n   subgraph cluster_1 {\n   color = lightgrey\n   label = \"thread 2\"\n   labeljust = \"l\"\n   run_2_1 [label = \"run(\\l\\\n     user_data,\\l\\\n     thread = 2,\\l\\\n     input = in[1],\\l\\\n     output = out[1],\\l\\\n     num_pixels = 20\\l\\\n   )\\l\"]\n   run_2_2 [label = \"run(\\l\\\n     user_data,\\l\\\n     thread = 2,\\l\\\n     input = in[4],\\l\\\n     output = out[4],\\l\\\n     num_pixels = 13\\l\\\n   )\\l\"]\n   }\n   subgraph cluster_3 {\n   color = lightgrey\n   label = \"thread 3\"\n   labeljust = \"c\"\n   run_3_1 [label = \"run(\\l\\\n     user_data,\\l\\\n     thread = 3,\\l\\\n     input = in[2],\\l\\\n     output = out[2],\\l\\\n     num_pixels = 20\\l\\\n   )\\l\"]\n   }\n   init -> {run_1_1; run_2_1; run_3_1; rank = same}\n   run_1_1 -> run_1_2\n   run_2_1 -> run_2_2\n   {run_1_2; run_2_2, run_3_1} -> \"destroy(user_data)\"\n }\n @enddot"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlCmsInterface {
    #[doc = " CMS-specific data that will be passed to @ref set_fields_from_icc."]
    pub set_fields_data: *mut ::std::os::raw::c_void,
    #[doc = " Populates a JxlColorEncoding from an ICC profile."]
    pub set_fields_from_icc: jpegxl_cms_set_fields_from_icc_func,
    #[doc = " CMS-specific data that will be passed to @ref init."]
    pub init_data: *mut ::std::os::raw::c_void,
    #[doc = " Prepares a colorspace transform as described in the documentation of @ref\n jpegxl_cms_init_func."]
    pub init: jpegxl_cms_init_func,
    #[doc = " Returns a buffer that can be used as input to @c run."]
    pub get_src_buf: jpegxl_cms_get_buffer_func,
    #[doc = " Returns a buffer that can be used as output from @c run."]
    pub get_dst_buf: jpegxl_cms_get_buffer_func,
    #[doc = " Executes the transform on a batch of pixels, per @ref jpegxl_cms_run_func."]
    pub run: jpegxl_cms_run_func,
    #[doc = " Cleans up the transform."]
    pub destroy: jpegxl_cms_destroy_func,
}
#[test]
fn bindgen_test_layout_JxlCmsInterface() {
    const UNINIT: ::std::mem::MaybeUninit<JxlCmsInterface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JxlCmsInterface>(),
        64usize,
        concat!("Size of: ", stringify!(JxlCmsInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<JxlCmsInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(JxlCmsInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_fields_data) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlCmsInterface),
        "::",
        stringify!(set_fields_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_fields_from_icc) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlCmsInterface),
        "::",
        stringify!(set_fields_from_icc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init_data) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlCmsInterface),
        "::",
        stringify!(init_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlCmsInterface),
        "::",
        stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_src_buf) as usize - ptr as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlCmsInterface),
        "::",
        stringify!(get_src_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_dst_buf) as usize - ptr as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlCmsInterface),
        "::",
        stringify!(get_dst_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).run) as usize - ptr as usize },
        48usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlCmsInterface),
        "::",
        stringify!(run)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        56usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlCmsInterface),
        "::",
        stringify!(destroy)
        )
    );
}
pub const JxlOrientation_JXL_ORIENT_IDENTITY: JxlOrientation = 1;
pub const JxlOrientation_JXL_ORIENT_FLIP_HORIZONTAL: JxlOrientation = 2;
pub const JxlOrientation_JXL_ORIENT_ROTATE_180: JxlOrientation = 3;
pub const JxlOrientation_JXL_ORIENT_FLIP_VERTICAL: JxlOrientation = 4;
pub const JxlOrientation_JXL_ORIENT_TRANSPOSE: JxlOrientation = 5;
pub const JxlOrientation_JXL_ORIENT_ROTATE_90_CW: JxlOrientation = 6;
pub const JxlOrientation_JXL_ORIENT_ANTI_TRANSPOSE: JxlOrientation = 7;
pub const JxlOrientation_JXL_ORIENT_ROTATE_90_CCW: JxlOrientation = 8;
#[doc = " Image orientation metadata.\n Values 1..8 match the EXIF definitions.\n The name indicates the operation to perform to transform from the encoded\n image to the display image."]
pub type JxlOrientation = ::std::os::raw::c_int;
pub const JxlExtraChannelType_JXL_CHANNEL_ALPHA: JxlExtraChannelType = 0;
pub const JxlExtraChannelType_JXL_CHANNEL_DEPTH: JxlExtraChannelType = 1;
pub const JxlExtraChannelType_JXL_CHANNEL_SPOT_COLOR: JxlExtraChannelType = 2;
pub const JxlExtraChannelType_JXL_CHANNEL_SELECTION_MASK: JxlExtraChannelType = 3;
pub const JxlExtraChannelType_JXL_CHANNEL_BLACK: JxlExtraChannelType = 4;
pub const JxlExtraChannelType_JXL_CHANNEL_CFA: JxlExtraChannelType = 5;
pub const JxlExtraChannelType_JXL_CHANNEL_THERMAL: JxlExtraChannelType = 6;
pub const JxlExtraChannelType_JXL_CHANNEL_RESERVED0: JxlExtraChannelType = 7;
pub const JxlExtraChannelType_JXL_CHANNEL_RESERVED1: JxlExtraChannelType = 8;
pub const JxlExtraChannelType_JXL_CHANNEL_RESERVED2: JxlExtraChannelType = 9;
pub const JxlExtraChannelType_JXL_CHANNEL_RESERVED3: JxlExtraChannelType = 10;
pub const JxlExtraChannelType_JXL_CHANNEL_RESERVED4: JxlExtraChannelType = 11;
pub const JxlExtraChannelType_JXL_CHANNEL_RESERVED5: JxlExtraChannelType = 12;
pub const JxlExtraChannelType_JXL_CHANNEL_RESERVED6: JxlExtraChannelType = 13;
pub const JxlExtraChannelType_JXL_CHANNEL_RESERVED7: JxlExtraChannelType = 14;
pub const JxlExtraChannelType_JXL_CHANNEL_UNKNOWN: JxlExtraChannelType = 15;
pub const JxlExtraChannelType_JXL_CHANNEL_OPTIONAL: JxlExtraChannelType = 16;
#[doc = " Given type of an extra channel."]
pub type JxlExtraChannelType = ::std::os::raw::c_int;
#[doc = " The codestream preview header"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlPreviewHeader {
    #[doc = " Preview width in pixels"]
    pub xsize: u32,
    #[doc = " Preview height in pixels"]
    pub ysize: u32,
}
#[test]
fn bindgen_test_layout_JxlPreviewHeader() {
    const UNINIT: ::std::mem::MaybeUninit<JxlPreviewHeader> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JxlPreviewHeader>(),
        8usize,
        concat!("Size of: ", stringify!(JxlPreviewHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<JxlPreviewHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(JxlPreviewHeader))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xsize) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlPreviewHeader),
        "::",
        stringify!(xsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ysize) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlPreviewHeader),
        "::",
        stringify!(ysize)
        )
    );
}
#[doc = " The codestream animation header, optionally present in the beginning of\n the codestream, and if it is it applies to all animation frames, unlike\n JxlFrameHeader which applies to an individual frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlAnimationHeader {
    #[doc = " Numerator of ticks per second of a single animation frame time unit"]
    pub tps_numerator: u32,
    #[doc = " Denominator of ticks per second of a single animation frame time unit"]
    pub tps_denominator: u32,
    #[doc = " Amount of animation loops, or 0 to repeat infinitely"]
    pub num_loops: u32,
    #[doc = " Whether animation time codes are present at animation frames in the\n codestream"]
    pub have_timecodes: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_JxlAnimationHeader() {
    const UNINIT: ::std::mem::MaybeUninit<JxlAnimationHeader> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JxlAnimationHeader>(),
        16usize,
        concat!("Size of: ", stringify!(JxlAnimationHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<JxlAnimationHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(JxlAnimationHeader))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tps_numerator) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlAnimationHeader),
        "::",
        stringify!(tps_numerator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tps_denominator) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlAnimationHeader),
        "::",
        stringify!(tps_denominator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_loops) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlAnimationHeader),
        "::",
        stringify!(num_loops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).have_timecodes) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlAnimationHeader),
        "::",
        stringify!(have_timecodes)
        )
    );
}
#[doc = " Basic image information. This information is available from the file\n signature and first part of the codestream header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlBasicInfo {
    #[doc = " Whether the codestream is embedded in the container format. If true,\n metadata information and extensions may be available in addition to the\n codestream."]
    pub have_container: ::std::os::raw::c_int,
    #[doc = " Width of the image in pixels, before applying orientation."]
    pub xsize: u32,
    #[doc = " Height of the image in pixels, before applying orientation."]
    pub ysize: u32,
    #[doc = " Original image color channel bit depth."]
    pub bits_per_sample: u32,
    #[doc = " Original image color channel floating point exponent bits, or 0 if they\n are unsigned integer. For example, if the original data is half-precision\n (binary16) floating point, bits_per_sample is 16 and\n exponent_bits_per_sample is 5, and so on for other floating point\n precisions."]
    pub exponent_bits_per_sample: u32,
    #[doc = " Upper bound on the intensity level present in the image in nits. For\n unsigned integer pixel encodings, this is the brightness of the largest\n representable value. The image does not necessarily contain a pixel\n actually this bright. An encoder is allowed to set 255 for SDR images\n without computing a histogram.\n Leaving this set to its default of 0 lets libjxl choose a sensible default\n value based on the color encoding."]
    pub intensity_target: f32,
    #[doc = " Lower bound on the intensity level present in the image. This may be\n loose, i.e. lower than the actual darkest pixel. When tone mapping, a\n decoder will map [min_nits, intensity_target] to the display range."]
    pub min_nits: f32,
    #[doc = " See the description of @see linear_below."]
    pub relative_to_max_display: ::std::os::raw::c_int,
    #[doc = " The tone mapping will leave unchanged (linear mapping) any pixels whose\n brightness is strictly below this. The interpretation depends on\n relative_to_max_display. If true, this is a ratio [0, 1] of the maximum\n display brightness [nits], otherwise an absolute brightness [nits]."]
    pub linear_below: f32,
    #[doc = " Whether the data in the codestream is encoded in the original color\n profile that is attached to the codestream metadata header, or is\n encoded in an internally supported absolute color space (which the decoder\n can always convert to linear or non-linear sRGB or to XYB). If the original\n profile is used, the decoder outputs pixel data in the color space matching\n that profile, but doesn't convert it to any other color space. If the\n original profile is not used, the decoder only outputs the data as sRGB\n (linear if outputting to floating point, nonlinear with standard sRGB\n transfer function if outputting to unsigned integers) but will not convert\n it to to the original color profile. The decoder also does not convert to\n the target display color profile. To convert the pixel data produced by\n the decoder to the original color profile, one of the JxlDecoderGetColor*\n functions needs to be called with @ref JXL_COLOR_PROFILE_TARGET_DATA to get\n the color profile of the decoder output, and then an external CMS can be\n used for conversion.\n Note that for lossy compression, this should be set to false for most use\n cases, and if needed, the image should be converted to the original color\n profile after decoding, as described above."]
    pub uses_original_profile: ::std::os::raw::c_int,
    #[doc = " Indicates a preview image exists near the beginning of the codestream.\n The preview itself or its dimensions are not included in the basic info."]
    pub have_preview: ::std::os::raw::c_int,
    #[doc = " Indicates animation frames exist in the codestream. The animation\n information is not included in the basic info."]
    pub have_animation: ::std::os::raw::c_int,
    #[doc = " Image orientation, value 1-8 matching the values used by JEITA CP-3451C\n (Exif version 2.3)."]
    pub orientation: JxlOrientation,
    #[doc = " Number of color channels encoded in the image, this is either 1 for\n grayscale data, or 3 for colored data. This count does not include\n the alpha channel or other extra channels. To check presence of an alpha\n channel, such as in the case of RGBA color, check alpha_bits != 0.\n If and only if this is 1, the JxlColorSpace in the JxlColorEncoding is\n JXL_COLOR_SPACE_GRAY."]
    pub num_color_channels: u32,
    #[doc = " Number of additional image channels. This includes the main alpha channel,\n but can also include additional channels such as depth, additional alpha\n channels, spot colors, and so on. Information about the extra channels\n can be queried with JxlDecoderGetExtraChannelInfo. The main alpha channel,\n if it exists, also has its information available in the alpha_bits,\n alpha_exponent_bits and alpha_premultiplied fields in this JxlBasicInfo."]
    pub num_extra_channels: u32,
    #[doc = " Bit depth of the encoded alpha channel, or 0 if there is no alpha channel.\n If present, matches the alpha_bits value of the JxlExtraChannelInfo\n associated with this alpha channel."]
    pub alpha_bits: u32,
    #[doc = " Alpha channel floating point exponent bits, or 0 if they are unsigned. If\n present, matches the alpha_bits value of the JxlExtraChannelInfo associated\n with this alpha channel. integer."]
    pub alpha_exponent_bits: u32,
    #[doc = " Whether the alpha channel is premultiplied. Only used if there is a main\n alpha channel. Matches the alpha_premultiplied value of the\n JxlExtraChannelInfo associated with this alpha channel."]
    pub alpha_premultiplied: ::std::os::raw::c_int,
    #[doc = " Dimensions of encoded preview image, only used if have_preview is\n JXL_TRUE."]
    pub preview: JxlPreviewHeader,
    #[doc = " Animation header with global animation properties for all frames, only\n used if have_animation is JXL_TRUE."]
    pub animation: JxlAnimationHeader,
    #[doc = " Intrinsic width of the image.\n The intrinsic size can be different from the actual size in pixels\n (as given by xsize and ysize) and it denotes the recommended dimensions\n for displaying the image, i.e. applications are advised to resample the\n decoded image to the intrinsic dimensions."]
    pub intrinsic_xsize: u32,
    #[doc = " Intrinsic height of the image.\n The intrinsic size can be different from the actual size in pixels\n (as given by xsize and ysize) and it denotes the recommended dimensions\n for displaying the image, i.e. applications are advised to resample the\n decoded image to the intrinsic dimensions."]
    pub intrinsic_ysize: u32,
    #[doc = " Padding for forwards-compatibility, in case more fields are exposed\n in a future version of the library."]
    pub padding: [u8; 100usize],
}
#[test]
fn bindgen_test_layout_JxlBasicInfo() {
    const UNINIT: ::std::mem::MaybeUninit<JxlBasicInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JxlBasicInfo>(),
        204usize,
        concat!("Size of: ", stringify!(JxlBasicInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<JxlBasicInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(JxlBasicInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).have_container) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(have_container)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xsize) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(xsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ysize) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(ysize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_per_sample) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(bits_per_sample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exponent_bits_per_sample) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(exponent_bits_per_sample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intensity_target) as usize - ptr as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(intensity_target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_nits) as usize - ptr as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(min_nits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).relative_to_max_display) as usize - ptr as usize },
        28usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(relative_to_max_display)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linear_below) as usize - ptr as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(linear_below)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uses_original_profile) as usize - ptr as usize },
        36usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(uses_original_profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).have_preview) as usize - ptr as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(have_preview)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).have_animation) as usize - ptr as usize },
        44usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(have_animation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).orientation) as usize - ptr as usize },
        48usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(orientation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_color_channels) as usize - ptr as usize },
        52usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(num_color_channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_extra_channels) as usize - ptr as usize },
        56usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(num_extra_channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha_bits) as usize - ptr as usize },
        60usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(alpha_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha_exponent_bits) as usize - ptr as usize },
        64usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(alpha_exponent_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha_premultiplied) as usize - ptr as usize },
        68usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(alpha_premultiplied)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preview) as usize - ptr as usize },
        72usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(preview)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).animation) as usize - ptr as usize },
        80usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(animation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intrinsic_xsize) as usize - ptr as usize },
        96usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(intrinsic_xsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intrinsic_ysize) as usize - ptr as usize },
        100usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(intrinsic_ysize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        104usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBasicInfo),
        "::",
        stringify!(padding)
        )
    );
}
#[doc = " Information for a single extra channel."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlExtraChannelInfo {
    #[doc = " Given type of an extra channel."]
    pub type_: JxlExtraChannelType,
    #[doc = " Total bits per sample for this channel."]
    pub bits_per_sample: u32,
    #[doc = " Floating point exponent bits per channel, or 0 if they are unsigned\n integer."]
    pub exponent_bits_per_sample: u32,
    #[doc = " The exponent the channel is downsampled by on each axis.\n TODO(lode): expand this comment to match the JPEG XL specification,\n specify how to upscale, how to round the size computation, and to which\n extra channels this field applies."]
    pub dim_shift: u32,
    #[doc = " Length of the extra channel name in bytes, or 0 if no name.\n Excludes null termination character."]
    pub name_length: u32,
    #[doc = " Whether alpha channel uses premultiplied alpha. Only applicable if\n type is JXL_CHANNEL_ALPHA."]
    pub alpha_premultiplied: ::std::os::raw::c_int,
    #[doc = " Spot color of the current spot channel in linear RGBA. Only applicable if\n type is JXL_CHANNEL_SPOT_COLOR."]
    pub spot_color: [f32; 4usize],
    #[doc = " Only applicable if type is JXL_CHANNEL_CFA.\n TODO(lode): add comment about the meaning of this field."]
    pub cfa_channel: u32,
}
#[test]
fn bindgen_test_layout_JxlExtraChannelInfo() {
    const UNINIT: ::std::mem::MaybeUninit<JxlExtraChannelInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JxlExtraChannelInfo>(),
        44usize,
        concat!("Size of: ", stringify!(JxlExtraChannelInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<JxlExtraChannelInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(JxlExtraChannelInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlExtraChannelInfo),
        "::",
        stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_per_sample) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlExtraChannelInfo),
        "::",
        stringify!(bits_per_sample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exponent_bits_per_sample) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlExtraChannelInfo),
        "::",
        stringify!(exponent_bits_per_sample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dim_shift) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlExtraChannelInfo),
        "::",
        stringify!(dim_shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_length) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlExtraChannelInfo),
        "::",
        stringify!(name_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha_premultiplied) as usize - ptr as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlExtraChannelInfo),
        "::",
        stringify!(alpha_premultiplied)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spot_color) as usize - ptr as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlExtraChannelInfo),
        "::",
        stringify!(spot_color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cfa_channel) as usize - ptr as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlExtraChannelInfo),
        "::",
        stringify!(cfa_channel)
        )
    );
}
#[doc = " Extensions in the codestream header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlHeaderExtensions {
    #[doc = " Extension bits."]
    pub extensions: u64,
}
#[test]
fn bindgen_test_layout_JxlHeaderExtensions() {
    const UNINIT: ::std::mem::MaybeUninit<JxlHeaderExtensions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JxlHeaderExtensions>(),
        8usize,
        concat!("Size of: ", stringify!(JxlHeaderExtensions))
    );
    assert_eq!(
        ::std::mem::align_of::<JxlHeaderExtensions>(),
        8usize,
        concat!("Alignment of ", stringify!(JxlHeaderExtensions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extensions) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlHeaderExtensions),
        "::",
        stringify!(extensions)
        )
    );
}
pub const JxlBlendMode_JXL_BLEND_REPLACE: JxlBlendMode = 0;
pub const JxlBlendMode_JXL_BLEND_ADD: JxlBlendMode = 1;
pub const JxlBlendMode_JXL_BLEND_BLEND: JxlBlendMode = 2;
pub const JxlBlendMode_JXL_BLEND_MULADD: JxlBlendMode = 3;
pub const JxlBlendMode_JXL_BLEND_MUL: JxlBlendMode = 4;
#[doc = " Frame blend modes.\n When decoding, if coalescing is enabled (default), this can be ignored."]
pub type JxlBlendMode = ::std::os::raw::c_int;
#[doc = " The information about blending the color channels or a single extra channel.\n When decoding, if coalescing is enabled (default), this can be ignored and\n the blend mode is considered to be JXL_BLEND_REPLACE.\n When encoding, these settings apply to the pixel data given to the encoder."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlBlendInfo {
    #[doc = " Blend mode."]
    pub blendmode: JxlBlendMode,
    #[doc = " Reference frame ID to use as the 'bottom' layer (0-3)."]
    pub source: u32,
    #[doc = " Which extra channel to use as the 'alpha' channel for blend modes\n JXL_BLEND_BLEND and JXL_BLEND_MULADD."]
    pub alpha: u32,
    #[doc = " Clamp values to [0,1] for the purpose of blending."]
    pub clamp: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_JxlBlendInfo() {
    const UNINIT: ::std::mem::MaybeUninit<JxlBlendInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JxlBlendInfo>(),
        16usize,
        concat!("Size of: ", stringify!(JxlBlendInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<JxlBlendInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(JxlBlendInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blendmode) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBlendInfo),
        "::",
        stringify!(blendmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBlendInfo),
        "::",
        stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBlendInfo),
        "::",
        stringify!(alpha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clamp) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlBlendInfo),
        "::",
        stringify!(clamp)
        )
    );
}
#[doc = " The information about layers.\n When decoding, if coalescing is enabled (default), this can be ignored.\n When encoding, these settings apply to the pixel data given to the encoder,\n the encoder could choose an internal representation that differs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlLayerInfo {
    #[doc = " Whether cropping is applied for this frame. When decoding, if false,\n crop_x0 and crop_y0 are set to zero, and xsize and ysize to the main\n image dimensions. When encoding and this is false, those fields are\n ignored. When decoding, if coalescing is enabled (default), this is always\n false, regardless of the internal encoding in the JPEG XL codestream."]
    pub have_crop: ::std::os::raw::c_int,
    #[doc = " Horizontal offset of the frame (can be negative)."]
    pub crop_x0: i32,
    #[doc = " Vertical offset of the frame (can be negative)."]
    pub crop_y0: i32,
    #[doc = " Width of the frame (number of columns)."]
    pub xsize: u32,
    #[doc = " Height of the frame (number of rows)."]
    pub ysize: u32,
    #[doc = " The blending info for the color channels. Blending info for extra channels\n has to be retrieved separately using JxlDecoderGetExtraChannelBlendInfo."]
    pub blend_info: JxlBlendInfo,
    #[doc = " After blending, save the frame as reference frame with this ID (0-3).\n Special case: if the frame duration is nonzero, ID 0 means \"will not be\n referenced in the future\". This value is not used for the last frame.\n When encoding, ID 3 is reserved to frames that are generated internally by\n the encoder, and should not be used by applications."]
    pub save_as_reference: u32,
}
#[test]
fn bindgen_test_layout_JxlLayerInfo() {
    const UNINIT: ::std::mem::MaybeUninit<JxlLayerInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JxlLayerInfo>(),
        40usize,
        concat!("Size of: ", stringify!(JxlLayerInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<JxlLayerInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(JxlLayerInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).have_crop) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlLayerInfo),
        "::",
        stringify!(have_crop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crop_x0) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlLayerInfo),
        "::",
        stringify!(crop_x0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crop_y0) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlLayerInfo),
        "::",
        stringify!(crop_y0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xsize) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlLayerInfo),
        "::",
        stringify!(xsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ysize) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlLayerInfo),
        "::",
        stringify!(ysize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blend_info) as usize - ptr as usize },
        20usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlLayerInfo),
        "::",
        stringify!(blend_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).save_as_reference) as usize - ptr as usize },
        36usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlLayerInfo),
        "::",
        stringify!(save_as_reference)
        )
    );
}
#[doc = " The header of one displayed frame or non-coalesced layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlFrameHeader {
    #[doc = " How long to wait after rendering in ticks. The duration in seconds of a\n tick is given by tps_numerator and tps_denominator in JxlAnimationHeader."]
    pub duration: u32,
    #[doc = " SMPTE timecode of the current frame in form 0xHHMMSSFF, or 0. The bits are\n interpreted from most-significant to least-significant as hour, minute,\n second, and frame. If timecode is nonzero, it is strictly larger than that\n of a previous frame with nonzero duration. These values are only available\n if have_timecodes in JxlAnimationHeader is JXL_TRUE.\n This value is only used if have_timecodes in JxlAnimationHeader is\n JXL_TRUE."]
    pub timecode: u32,
    #[doc = " Length of the frame name in bytes, or 0 if no name.\n Excludes null termination character. This value is set by the decoder.\n For the encoder, this value is ignored and @ref JxlEncoderSetFrameName is\n used instead to set the name and the length."]
    pub name_length: u32,
    #[doc = " Indicates this is the last animation frame. This value is set by the\n decoder to indicate no further frames follow. For the encoder, it is not\n required to set this value and it is ignored, @ref JxlEncoderCloseFrames is\n used to indicate the last frame to the encoder instead."]
    pub is_last: ::std::os::raw::c_int,
    #[doc = " Information about the layer in case of no coalescing."]
    pub layer_info: JxlLayerInfo,
}
#[test]
fn bindgen_test_layout_JxlFrameHeader() {
    const UNINIT: ::std::mem::MaybeUninit<JxlFrameHeader> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JxlFrameHeader>(),
        56usize,
        concat!("Size of: ", stringify!(JxlFrameHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<JxlFrameHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(JxlFrameHeader))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlFrameHeader),
        "::",
        stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timecode) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlFrameHeader),
        "::",
        stringify!(timecode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_length) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlFrameHeader),
        "::",
        stringify!(name_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_last) as usize - ptr as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlFrameHeader),
        "::",
        stringify!(is_last)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layer_info) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlFrameHeader),
        "::",
        stringify!(layer_info)
        )
    );
}
#[doc = " Allocating function for a memory region of a given size.\n\n Allocates a contiguous memory region of size @p size bytes. The returned\n memory may not be aligned to a specific size or initialized at all.\n\n @param opaque custom memory manager handle provided by the caller.\n @param size in bytes of the requested memory region.\n @return @c NULL if the memory can not be allocated,\n @return pointer to the memory otherwise."]
pub type jpegxl_alloc_func = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Deallocating function pointer type.\n\n This function @b MUST do nothing if @p address is @c NULL.\n\n @param opaque custom memory manager handle provided by the caller.\n @param address memory region pointer returned by ::jpegxl_alloc_func, or @c\n NULL."]
pub type jpegxl_free_func = ::std::option::Option<
    unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, address: *mut ::std::os::raw::c_void),
>;
#[doc = " Memory Manager struct.\n These functions, when provided by the caller, will be used to handle memory\n allocations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlMemoryManagerStruct {
    #[doc = " The opaque pointer that will be passed as the first parameter to all the\n functions in this struct."]
    pub opaque: *mut ::std::os::raw::c_void,
    #[doc = " Memory allocation function. This can be NULL if and only if also the\n free() member in this class is NULL. All dynamic memory will be allocated\n and freed with these functions if they are not NULL."]
    pub alloc: jpegxl_alloc_func,
    #[doc = " Free function matching the alloc() member."]
    pub free: jpegxl_free_func,
}
#[test]
fn bindgen_test_layout_JxlMemoryManagerStruct() {
    const UNINIT: ::std::mem::MaybeUninit<JxlMemoryManagerStruct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JxlMemoryManagerStruct>(),
        24usize,
        concat!("Size of: ", stringify!(JxlMemoryManagerStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<JxlMemoryManagerStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(JxlMemoryManagerStruct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlMemoryManagerStruct),
        "::",
        stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlMemoryManagerStruct),
        "::",
        stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlMemoryManagerStruct),
        "::",
        stringify!(free)
        )
    );
}
#[doc = " Memory Manager struct.\n These functions, when provided by the caller, will be used to handle memory\n allocations."]
pub type JxlMemoryManager = JxlMemoryManagerStruct;
#[doc = " Return code used in the JxlParallel* functions as return value. A value\n of 0 means success and any other value means error. The special value\n JXL_PARALLEL_RET_RUNNER_ERROR can be used by the runner to indicate any\n other error."]
pub type JxlParallelRetCode = ::std::os::raw::c_int;
#[doc = " Parallel run initialization callback. See JxlParallelRunner for details.\n\n This function MUST be called by the JxlParallelRunner only once, on the\n same thread that called JxlParallelRunner, before any parallel execution.\n The purpose of this call is to provide the maximum number of threads that the\n JxlParallelRunner will use, which can be used by JPEG XL to allocate\n per-thread storage if needed.\n\n @param jpegxl_opaque the @p jpegxl_opaque handle provided to\n JxlParallelRunner() must be passed here.\n @param num_threads the maximum number of threads. This value must be\n positive.\n @return 0 if the initialization process was successful.\n @return an error code if there was an error, which should be returned by\n JxlParallelRunner()."]
pub type JxlParallelRunInit = ::std::option::Option<
    unsafe extern "C" fn(
        jpegxl_opaque: *mut ::std::os::raw::c_void,
        num_threads: usize,
    ) -> JxlParallelRetCode,
>;
#[doc = " Parallel run data processing callback. See JxlParallelRunner for details.\n\n This function MUST be called once for every number in the range [start_range,\n end_range) (including start_range but not including end_range) passing this\n number as the @p value. Calls for different value may be executed from\n different threads in parallel.\n\n @param jpegxl_opaque the @p jpegxl_opaque handle provided to\n JxlParallelRunner() must be passed here.\n @param value the number in the range [start_range, end_range) of the call.\n @param thread_id the thread number where this function is being called from.\n This must be lower than the @p num_threads value passed to\n JxlParallelRunInit."]
pub type JxlParallelRunFunction = ::std::option::Option<
    unsafe extern "C" fn(jpegxl_opaque: *mut ::std::os::raw::c_void, value: u32, thread_id: usize),
>;
#[doc = " JxlParallelRunner function type. A parallel runner implementation can be\n provided by a JPEG XL caller to allow running computations in multiple\n threads. This function must call the initialization function @p init in the\n same thread that called it and then call the passed @p func once for every\n number in the range [start_range, end_range) (including start_range but not\n including end_range) possibly from different multiple threads in parallel.\n\n The JxlParallelRunner function does not need to be re-entrant. This means\n that the same JxlParallelRunner function with the same runner_opaque\n provided parameter will not be called from the library from either @p init or\n @p func in the same decoder or encoder instance. However, a single decoding\n or encoding instance may call the provided JxlParallelRunner multiple\n times for different parts of the decoding or encoding process.\n\n @return 0 if the @p init call succeeded (returned 0) and no other error\n occurred in the runner code.\n @return JXL_PARALLEL_RET_RUNNER_ERROR if an error occurred in the runner\n code, for example, setting up the threads.\n @return the return value of @p init() if non-zero."]
pub type JxlParallelRunner = ::std::option::Option<
    unsafe extern "C" fn(
        runner_opaque: *mut ::std::os::raw::c_void,
        jpegxl_opaque: *mut ::std::os::raw::c_void,
        init: JxlParallelRunInit,
        func: JxlParallelRunFunction,
        start_range: u32,
        end_range: u32,
    ) -> JxlParallelRetCode,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlEncoderStatsStruct {
    _unused: [u8; 0],
}
#[doc = " Opaque structure that holds the encoder statistics.\n\n Allocated and initialized with JxlEncoderStatsCreate().\n Cleaned up and deallocated with JxlEncoderStatsDestroy()."]
pub type JxlEncoderStats = JxlEncoderStatsStruct;
extern "C" {
    #[doc = " Creates an instance of JxlEncoderStats and initializes it.\n\n @return pointer to initialized JxlEncoderStats instance"]
    pub fn JxlEncoderStatsCreate() -> *mut JxlEncoderStats;
}
extern "C" {
    #[doc = " Deinitializes and frees JxlEncoderStats instance.\n\n @param stats instance to be cleaned up and deallocated. No-op if stats is\n null pointer."]
    pub fn JxlEncoderStatsDestroy(stats: *mut JxlEncoderStats);
}
pub const JxlEncoderStatsKey_JXL_ENC_STAT_HEADER_BITS: JxlEncoderStatsKey = 0;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_TOC_BITS: JxlEncoderStatsKey = 1;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_DICTIONARY_BITS: JxlEncoderStatsKey = 2;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_SPLINES_BITS: JxlEncoderStatsKey = 3;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_NOISE_BITS: JxlEncoderStatsKey = 4;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_QUANT_BITS: JxlEncoderStatsKey = 5;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_MODULAR_TREE_BITS: JxlEncoderStatsKey = 6;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_MODULAR_GLOBAL_BITS: JxlEncoderStatsKey = 7;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_DC_BITS: JxlEncoderStatsKey = 8;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_MODULAR_DC_GROUP_BITS: JxlEncoderStatsKey = 9;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_CONTROL_FIELDS_BITS: JxlEncoderStatsKey = 10;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_COEF_ORDER_BITS: JxlEncoderStatsKey = 11;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_AC_HISTOGRAM_BITS: JxlEncoderStatsKey = 12;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_AC_BITS: JxlEncoderStatsKey = 13;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_MODULAR_AC_GROUP_BITS: JxlEncoderStatsKey = 14;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_NUM_SMALL_BLOCKS: JxlEncoderStatsKey = 15;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_NUM_DCT4X8_BLOCKS: JxlEncoderStatsKey = 16;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_NUM_AFV_BLOCKS: JxlEncoderStatsKey = 17;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_NUM_DCT8_BLOCKS: JxlEncoderStatsKey = 18;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_NUM_DCT8X32_BLOCKS: JxlEncoderStatsKey = 19;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_NUM_DCT16_BLOCKS: JxlEncoderStatsKey = 20;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_NUM_DCT16X32_BLOCKS: JxlEncoderStatsKey = 21;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_NUM_DCT32_BLOCKS: JxlEncoderStatsKey = 22;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_NUM_DCT32X64_BLOCKS: JxlEncoderStatsKey = 23;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_NUM_DCT64_BLOCKS: JxlEncoderStatsKey = 24;
pub const JxlEncoderStatsKey_JXL_ENC_STAT_NUM_BUTTERAUGLI_ITERS: JxlEncoderStatsKey = 25;
pub const JxlEncoderStatsKey_JXL_ENC_NUM_STATS: JxlEncoderStatsKey = 26;
#[doc = " Data type for querying JxlEncoderStats object"]
pub type JxlEncoderStatsKey = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Returns the value of the statistics corresponding the given key.\n\n @param stats object that was passed to the encoder with a\n   @ref JxlEncoderCollectStats function\n @param key the particular statistics to query\n\n @return the value of the statistics"]
    pub fn JxlEncoderStatsGet(stats: *const JxlEncoderStats, key: JxlEncoderStatsKey) -> usize;
}
extern "C" {
    #[doc = " Updates the values of the given stats object with that of an other.\n\n @param stats object whose values will be updated (usually added together)\n @param other stats object whose values will be merged with stats"]
    pub fn JxlEncoderStatsMerge(stats: *mut JxlEncoderStats, other: *const JxlEncoderStats);
}
extern "C" {
    #[doc = " Encoder library version.\n\n @return the encoder library version as an integer:\n MAJOR_VERSION * 1000000 + MINOR_VERSION * 1000 + PATCH_VERSION. For example,\n version 1.2.3 would return 1002003."]
    pub fn JxlEncoderVersion() -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlEncoderStruct {
    _unused: [u8; 0],
}
#[doc = " Opaque structure that holds the JPEG XL encoder.\n\n Allocated and initialized with JxlEncoderCreate().\n Cleaned up and deallocated with JxlEncoderDestroy()."]
pub type JxlEncoder = JxlEncoderStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlEncoderFrameSettingsStruct {
    _unused: [u8; 0],
}
#[doc = " Settings and metadata for a single image frame. This includes encoder options\n for a frame such as compression quality and speed.\n\n Allocated and initialized with JxlEncoderFrameSettingsCreate().\n Cleaned up and deallocated when the encoder is destroyed with\n JxlEncoderDestroy()."]
pub type JxlEncoderFrameSettings = JxlEncoderFrameSettingsStruct;
#[doc = " Function call finished successfully, or encoding is finished and there is\n nothing more to be done."]
pub const JxlEncoderStatus_JXL_ENC_SUCCESS: JxlEncoderStatus = 0;
#[doc = " An error occurred, for example out of memory."]
pub const JxlEncoderStatus_JXL_ENC_ERROR: JxlEncoderStatus = 1;
#[doc = " The encoder needs more output buffer to continue encoding."]
pub const JxlEncoderStatus_JXL_ENC_NEED_MORE_OUTPUT: JxlEncoderStatus = 2;
#[doc = " Return value for multiple encoder functions."]
pub type JxlEncoderStatus = ::std::os::raw::c_int;
#[doc = " No error"]
pub const JxlEncoderError_JXL_ENC_ERR_OK: JxlEncoderError = 0;
#[doc = " Generic encoder error due to unspecified cause"]
pub const JxlEncoderError_JXL_ENC_ERR_GENERIC: JxlEncoderError = 1;
#[doc = " Out of memory\n  TODO(jon): actually catch this and return this error"]
pub const JxlEncoderError_JXL_ENC_ERR_OOM: JxlEncoderError = 2;
#[doc = " JPEG bitstream reconstruction data could not be\n  represented (e.g. too much tail data)"]
pub const JxlEncoderError_JXL_ENC_ERR_JBRD: JxlEncoderError = 3;
#[doc = " Input is invalid (e.g. corrupt JPEG file or ICC profile)"]
pub const JxlEncoderError_JXL_ENC_ERR_BAD_INPUT: JxlEncoderError = 4;
#[doc = " The encoder doesn't (yet) support this. Either no version of libjxl\n supports this, and the API is used incorrectly, or the libjxl version\n should have been checked before trying to do this."]
pub const JxlEncoderError_JXL_ENC_ERR_NOT_SUPPORTED: JxlEncoderError = 128;
#[doc = " The encoder API is used in an incorrect way.\n  In this case, a debug build of libjxl should output a specific error\n message. (if not, please open an issue about it)"]
pub const JxlEncoderError_JXL_ENC_ERR_API_USAGE: JxlEncoderError = 129;
#[doc = " Error conditions:\n API usage errors have the 0x80 bit set to 1\n Other errors have the 0x80 bit set to 0"]
pub type JxlEncoderError = ::std::os::raw::c_int;
#[doc = " Sets encoder effort/speed level without affecting decoding speed. Valid\n values are, from faster to slower speed: 1:lightning 2:thunder 3:falcon\n 4:cheetah 5:hare 6:wombat 7:squirrel 8:kitten 9:tortoise.\n Default: squirrel (7)."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_EFFORT: JxlEncoderFrameSettingId = 0;
#[doc = " Sets the decoding speed tier for the provided options. Minimum is 0\n (slowest to decode, best quality/density), and maximum is 4 (fastest to\n decode, at the cost of some quality/density). Default is 0."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_DECODING_SPEED: JxlEncoderFrameSettingId =
    1;
#[doc = " Sets resampling option. If enabled, the image is downsampled before\n compression, and upsampled to original size in the decoder. Integer option,\n use -1 for the default behavior (resampling only applied for low quality),\n 1 for no downsampling (1x1), 2 for 2x2 downsampling, 4 for 4x4\n downsampling, 8 for 8x8 downsampling."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_RESAMPLING: JxlEncoderFrameSettingId = 2;
#[doc = " Similar to JXL_ENC_FRAME_SETTING_RESAMPLING, but for extra channels.\n Integer option, use -1 for the default behavior (depends on encoder\n implementation), 1 for no downsampling (1x1), 2 for 2x2 downsampling, 4 for\n 4x4 downsampling, 8 for 8x8 downsampling."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_EXTRA_CHANNEL_RESAMPLING:
JxlEncoderFrameSettingId = 3;
#[doc = " Indicates the frame added with @ref JxlEncoderAddImageFrame is already\n downsampled by the downsampling factor set with @ref\n JXL_ENC_FRAME_SETTING_RESAMPLING. The input frame must then be given in the\n downsampled resolution, not the full image resolution. The downsampled\n resolution is given by ceil(xsize / resampling), ceil(ysize / resampling)\n with xsize and ysize the dimensions given in the basic info, and resampling\n the factor set with @ref JXL_ENC_FRAME_SETTING_RESAMPLING.\n Use 0 to disable, 1 to enable. Default value is 0."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_ALREADY_DOWNSAMPLED:
JxlEncoderFrameSettingId = 4;
#[doc = " Adds noise to the image emulating photographic film noise, the higher the\n given number, the grainier the image will be. As an example, a value of 100\n gives low noise whereas a value of 3200 gives a lot of noise. The default\n value is 0."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_PHOTON_NOISE: JxlEncoderFrameSettingId = 5;
#[doc = " Enables adaptive noise generation. This setting is not recommended for\n use, please use JXL_ENC_FRAME_SETTING_PHOTON_NOISE instead. Use -1 for the\n default (encoder chooses), 0 to disable, 1 to enable."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_NOISE: JxlEncoderFrameSettingId = 6;
#[doc = " Enables or disables dots generation. Use -1 for the default (encoder\n chooses), 0 to disable, 1 to enable."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_DOTS: JxlEncoderFrameSettingId = 7;
#[doc = " Enables or disables patches generation. Use -1 for the default (encoder\n chooses), 0 to disable, 1 to enable."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_PATCHES: JxlEncoderFrameSettingId = 8;
#[doc = " Edge preserving filter level, -1 to 3. Use -1 for the default (encoder\n chooses), 0 to 3 to set a strength."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_EPF: JxlEncoderFrameSettingId = 9;
#[doc = " Enables or disables the gaborish filter. Use -1 for the default (encoder\n chooses), 0 to disable, 1 to enable."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_GABORISH: JxlEncoderFrameSettingId = 10;
#[doc = " Enables modular encoding. Use -1 for default (encoder\n chooses), 0 to enforce VarDCT mode (e.g. for photographic images), 1 to\n enforce modular mode (e.g. for lossless images)."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_MODULAR: JxlEncoderFrameSettingId = 11;
#[doc = " Enables or disables preserving color of invisible pixels. Use -1 for the\n default (1 if lossless, 0 if lossy), 0 to disable, 1 to enable."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_KEEP_INVISIBLE: JxlEncoderFrameSettingId =
    12;
#[doc = " Determines the order in which 256x256 regions are stored in the codestream\n for progressive rendering. Use -1 for the encoder\n default, 0 for scanline order, 1 for center-first order."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_GROUP_ORDER: JxlEncoderFrameSettingId = 13;
#[doc = " Determines the horizontal position of center for the center-first group\n order. Use -1 to automatically use the middle of the image, 0..xsize to\n specifically set it."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_GROUP_ORDER_CENTER_X:
JxlEncoderFrameSettingId = 14;
#[doc = " Determines the center for the center-first group order. Use -1 to\n automatically use the middle of the image, 0..ysize to specifically set it."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_GROUP_ORDER_CENTER_Y:
JxlEncoderFrameSettingId = 15;
#[doc = " Enables or disables progressive encoding for modular mode. Use -1 for the\n encoder default, 0 to disable, 1 to enable."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_RESPONSIVE: JxlEncoderFrameSettingId = 16;
#[doc = " Set the progressive mode for the AC coefficients of VarDCT, using spectral\n progression from the DCT coefficients. Use -1 for the encoder default, 0 to\n disable, 1 to enable."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_PROGRESSIVE_AC: JxlEncoderFrameSettingId =
    17;
#[doc = " Set the progressive mode for the AC coefficients of VarDCT, using\n quantization of the least significant bits. Use -1 for the encoder default,\n 0 to disable, 1 to enable."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_QPROGRESSIVE_AC: JxlEncoderFrameSettingId =
    18;
#[doc = " Set the progressive mode using lower-resolution DC images for VarDCT. Use\n -1 for the encoder default, 0 to disable, 1 to have an extra 64x64 lower\n resolution pass, 2 to have a 512x512 and 64x64 lower resolution pass."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_PROGRESSIVE_DC: JxlEncoderFrameSettingId =
    19;
#[doc = " Use Global channel palette if the amount of colors is smaller than this\n percentage of range. Use 0-100 to set an explicit percentage, -1 to use the\n encoder default. Used for modular encoding."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_CHANNEL_COLORS_GLOBAL_PERCENT:
JxlEncoderFrameSettingId = 20;
#[doc = " Use Local (per-group) channel palette if the amount of colors is smaller\n than this percentage of range. Use 0-100 to set an explicit percentage, -1\n to use the encoder default. Used for modular encoding."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_CHANNEL_COLORS_GROUP_PERCENT:
JxlEncoderFrameSettingId = 21;
#[doc = " Use color palette if amount of colors is smaller than or equal to this\n amount, or -1 to use the encoder default. Used for modular encoding."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_PALETTE_COLORS: JxlEncoderFrameSettingId =
    22;
#[doc = " Enables or disables delta palette. Use -1 for the default (encoder\n chooses), 0 to disable, 1 to enable. Used in modular mode."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_LOSSY_PALETTE: JxlEncoderFrameSettingId =
    23;
#[doc = " Color transform for internal encoding: -1 = default, 0=XYB, 1=none (RGB),\n 2=YCbCr. The XYB setting performs the forward XYB transform. None and\n YCbCr both perform no transform, but YCbCr is used to indicate that the\n encoded data losslessly represents YCbCr values."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_COLOR_TRANSFORM: JxlEncoderFrameSettingId =
    24;
#[doc = " Reversible color transform for modular encoding: -1=default, 0-41=RCT\n index, e.g. index 0 = none, index 6 = YCoCg.\n If this option is set to a non-default value, the RCT will be globally\n applied to the whole frame.\n The default behavior is to try several RCTs locally per modular group,\n depending on the speed and distance setting."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_MODULAR_COLOR_SPACE:
JxlEncoderFrameSettingId = 25;
#[doc = " Group size for modular encoding: -1=default, 0=128, 1=256, 2=512, 3=1024."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_MODULAR_GROUP_SIZE:
JxlEncoderFrameSettingId = 26;
#[doc = " Predictor for modular encoding. -1 = default, 0=zero, 1=left, 2=top,\n 3=avg0, 4=select, 5=gradient, 6=weighted, 7=topright, 8=topleft,\n 9=leftleft, 10=avg1, 11=avg2, 12=avg3, 13=toptop predictive average 14=mix\n 5 and 6, 15=mix everything."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_MODULAR_PREDICTOR:
JxlEncoderFrameSettingId = 27;
#[doc = " Fraction of pixels used to learn MA trees as a percentage. -1 = default,\n 0 = no MA and fast decode, 50 = default value, 100 = all, values above\n 100 are also permitted. Higher values use more encoder memory."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_MODULAR_MA_TREE_LEARNING_PERCENT:
JxlEncoderFrameSettingId = 28;
#[doc = " Number of extra (previous-channel) MA tree properties to use. -1 =\n default, 0-11 = valid values. Recommended values are in the range 0 to 3,\n or 0 to amount of channels minus 1 (including all extra channels, and\n excluding color channels when using VarDCT mode). Higher value gives slower\n encoding and slower decoding."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_MODULAR_NB_PREV_CHANNELS:
JxlEncoderFrameSettingId = 29;
#[doc = " Enable or disable CFL (chroma-from-luma) for lossless JPEG recompression.\n -1 = default, 0 = disable CFL, 1 = enable CFL."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_JPEG_RECON_CFL: JxlEncoderFrameSettingId =
    30;
#[doc = " Prepare the frame for indexing in the frame index box.\n 0 = ignore this frame (same as not setting a value),\n 1 = index this frame within the Frame Index Box.\n If any frames are indexed, the first frame needs to\n be indexed, too. If the first frame is not indexed, and\n a later frame is attempted to be indexed, JXL_ENC_ERROR will occur.\n If non-keyframes, i.e., frames with cropping, blending or patches are\n attempted to be indexed, JXL_ENC_ERROR will occur."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_INDEX_BOX: JxlEncoderFrameSettingId = 31;
#[doc = " Sets brotli encode effort for use in JPEG recompression and compressed\n metadata boxes (brob). Can be -1 (default) or 0 (fastest) to 11 (slowest).\n Default is based on the general encode effort in case of JPEG\n recompression, and 4 for brob boxes."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_BROTLI_EFFORT: JxlEncoderFrameSettingId =
    32;
#[doc = " Enables or disables brotli compression of metadata boxes derived from\n a JPEG frame when using JxlEncoderAddJPEGFrame. This has no effect on boxes\n added using JxlEncoderAddBox.\n -1 = default, 0 = disable compression, 1 = enable compression."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_JPEG_COMPRESS_BOXES:
JxlEncoderFrameSettingId = 33;
#[doc = " Control what kind of buffering is used, when using chunked image frames.\n 0 = buffers everything, basically the same as non-streamed code path\n(mainly for testing)\n 1 = can buffer internal data (the tokens)\n 2 = can buffer the output\n 3 = minimize buffer usage: streamed input and chunked output, writing TOC\nlast (will not work with progressive)\n\nWhen the image dimensions is smaller than 2048 x 2048 all the options are the\nsame. Using 1, 2 or 3 can result increasingly in less compression density."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_BUFFERING: JxlEncoderFrameSettingId = 34;
#[doc = " Keep or discard Exif metadata boxes derived from a JPEG frame when using\n JxlEncoderAddJPEGFrame. This has no effect on boxes added using\n JxlEncoderAddBox. When JxlEncoderStoreJPEGMetadata is set to 1, this option\n cannot be set to 0. Even when Exif metadata is discarded, the orientation\n will still be applied. 0 = discard Exif metadata, 1 = keep Exif metadata\n (default)."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_JPEG_KEEP_EXIF: JxlEncoderFrameSettingId =
    35;
#[doc = " Keep or discard XMP metadata boxes derived from a JPEG frame when using\n JxlEncoderAddJPEGFrame. This has no effect on boxes added using\n JxlEncoderAddBox. When JxlEncoderStoreJPEGMetadata is set to 1, this option\n cannot be set to 0. 0 = discard XMP metadata, 1 = keep XMP metadata\n (default)."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_JPEG_KEEP_XMP: JxlEncoderFrameSettingId =
    36;
#[doc = " Keep or discard JUMBF metadata boxes derived from a JPEG frame when using\n JxlEncoderAddJPEGFrame. This has no effect on boxes added using\n JxlEncoderAddBox. 0 = discard JUMBF metadata, 1 = keep JUMBF metadata\n (default)."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_JPEG_KEEP_JUMBF: JxlEncoderFrameSettingId =
    37;
#[doc = " Enum value not to be used as an option. This value is added to force the\n C compiler to have the enum to take a known size."]
pub const JxlEncoderFrameSettingId_JXL_ENC_FRAME_SETTING_FILL_ENUM: JxlEncoderFrameSettingId =
    65535;
#[doc = " Id of encoder options for a frame. This includes options such as setting\n encoding effort/speed or overriding the use of certain coding tools, for this\n frame. This does not include non-frame related encoder options such as for\n boxes."]
pub type JxlEncoderFrameSettingId = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Creates an instance of JxlEncoder and initializes it.\n\n @p memory_manager will be used for all the library dynamic allocations made\n from this instance. The parameter may be NULL, in which case the default\n allocator will be used. See jpegxl/memory_manager.h for details.\n\n @param memory_manager custom allocator function. It may be NULL. The memory\n        manager will be copied internally.\n @return @c NULL if the instance can not be allocated or initialized\n @return pointer to initialized JxlEncoder otherwise"]
    pub fn JxlEncoderCreate(memory_manager: *const JxlMemoryManager) -> *mut JxlEncoder;
}
extern "C" {
    #[doc = " Re-initializes a JxlEncoder instance, so it can be re-used for encoding\n another image. All state and settings are reset as if the object was\n newly created with JxlEncoderCreate, but the memory manager is kept.\n\n @param enc instance to be re-initialized."]
    pub fn JxlEncoderReset(enc: *mut JxlEncoder);
}
extern "C" {
    #[doc = " Deinitializes and frees JxlEncoder instance.\n\n @param enc instance to be cleaned up and deallocated."]
    pub fn JxlEncoderDestroy(enc: *mut JxlEncoder);
}
extern "C" {
    #[doc = " Sets the color management system (CMS) that will be used for color conversion\n (if applicable) during encoding. May only be set before starting encoding. If\n left unset, the default CMS implementation will be used.\n\n @param enc encoder object.\n @param cms structure representing a CMS implementation. See JxlCmsInterface\n for more details."]
    pub fn JxlEncoderSetCms(enc: *mut JxlEncoder, cms: JxlCmsInterface);
}
extern "C" {
    #[doc = " Set the parallel runner for multithreading. May only be set before starting\n encoding.\n\n @param enc encoder object.\n @param parallel_runner function pointer to runner for multithreading. It may\n        be NULL to use the default, single-threaded, runner. A multithreaded\n        runner should be set to reach fast performance.\n @param parallel_runner_opaque opaque pointer for parallel_runner.\n @return JXL_ENC_SUCCESS if the runner was set, JXL_ENC_ERROR\n otherwise (the previous runner remains set)."]
    pub fn JxlEncoderSetParallelRunner(
        enc: *mut JxlEncoder,
        parallel_runner: JxlParallelRunner,
        parallel_runner_opaque: *mut ::std::os::raw::c_void,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Get the (last) error code in case JXL_ENC_ERROR was returned.\n\n @param enc encoder object.\n @return the JxlEncoderError that caused the (last) JXL_ENC_ERROR to be\n returned."]
    pub fn JxlEncoderGetError(enc: *mut JxlEncoder) -> JxlEncoderError;
}
extern "C" {
    #[doc = " Encodes JPEG XL file using the available bytes. @p *avail_out indicates how\n many output bytes are available, and @p *next_out points to the input bytes.\n *avail_out will be decremented by the amount of bytes that have been\n processed by the encoder and *next_out will be incremented by the same\n amount, so *next_out will now point at the amount of *avail_out unprocessed\n bytes.\n\n The returned status indicates whether the encoder needs more output bytes.\n When the return value is not JXL_ENC_ERROR or JXL_ENC_SUCCESS, the encoding\n requires more JxlEncoderProcessOutput calls to continue.\n\n The caller must guarantee that *avail_out >= 32 when calling\n JxlEncoderProcessOutput; otherwise, JXL_ENC_NEED_MORE_OUTPUT will be\n returned. It is guaranteed that, if *avail_out >= 32, at least one byte of\n output will be written.\n\n This encodes the frames and/or boxes added so far. If the last frame or last\n box has been added, @ref JxlEncoderCloseInput, @ref JxlEncoderCloseFrames\n and/or @ref JxlEncoderCloseBoxes must be called before the next\n @ref JxlEncoderProcessOutput call, or the codestream won't be encoded\n correctly.\n\n @param enc encoder object.\n @param next_out pointer to next bytes to write to.\n @param avail_out amount of bytes available starting from *next_out.\n @return JXL_ENC_SUCCESS when encoding finished and all events handled.\n @return JXL_ENC_ERROR when encoding failed, e.g. invalid input.\n @return JXL_ENC_NEED_MORE_OUTPUT more output buffer is necessary."]
    pub fn JxlEncoderProcessOutput(
        enc: *mut JxlEncoder,
        next_out: *mut *mut u8,
        avail_out: *mut usize,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Sets the frame information for this frame to the encoder. This includes\n animation information such as frame duration to store in the frame header.\n The frame header fields represent the frame as passed to the encoder, but not\n necessarily the exact values as they will be encoded file format: the encoder\n could change crop and blending options of a frame for more efficient encoding\n or introduce additional internal frames. Animation duration and time code\n information is not altered since those are immutable metadata of the frame.\n\n It is not required to use this function, however if have_animation is set\n to true in the basic info, then this function should be used to set the\n time duration of this individual frame. By default individual frames have a\n time duration of 0, making them form a composite still. See @ref\n JxlFrameHeader for more information.\n\n This information is stored in the JxlEncoderFrameSettings and so is used for\n any frame encoded with these JxlEncoderFrameSettings. It is ok to change\n between @ref JxlEncoderAddImageFrame calls, each added image frame will have\n the frame header that was set in the options at the time of calling\n JxlEncoderAddImageFrame.\n\n The is_last and name_length fields of the JxlFrameHeader are ignored, use\n @ref JxlEncoderCloseFrames to indicate last frame, and @ref\n JxlEncoderSetFrameName to indicate the name and its length instead.\n Calling this function will clear any name that was previously set with @ref\n JxlEncoderSetFrameName.\n\n @param frame_settings set of options and metadata for this frame. Also\n includes reference to the encoder object.\n @param frame_header frame header data to set. Object owned by the caller and\n does not need to be kept in memory, its information is copied internally.\n @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error"]
    pub fn JxlEncoderSetFrameHeader(
        frame_settings: *mut JxlEncoderFrameSettings,
        frame_header: *const JxlFrameHeader,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Sets blend info of an extra channel. The blend info of extra channels is set\n separately from that of the color channels, the color channels are set with\n @ref JxlEncoderSetFrameHeader.\n\n @param frame_settings set of options and metadata for this frame. Also\n includes reference to the encoder object.\n @param index index of the extra channel to use.\n @param blend_info blend info to set for the extra channel\n @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error"]
    pub fn JxlEncoderSetExtraChannelBlendInfo(
        frame_settings: *mut JxlEncoderFrameSettings,
        index: usize,
        blend_info: *const JxlBlendInfo,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Sets the name of the animation frame. This function is optional, frames are\n not required to have a name. This setting is a part of the frame header, and\n the same principles as for @ref JxlEncoderSetFrameHeader apply. The\n name_length field of JxlFrameHeader is ignored by the encoder, this function\n determines the name length instead as the length in bytes of the C string.\n\n The maximum possible name length is 1071 bytes (excluding terminating null\n character).\n\n Calling @ref JxlEncoderSetFrameHeader clears any name that was\n previously set.\n\n @param frame_settings set of options and metadata for this frame. Also\n includes reference to the encoder object.\n @param frame_name name of the next frame to be encoded, as a UTF-8 encoded C\n string (zero terminated). Owned by the caller, and copied internally.\n @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error"]
    pub fn JxlEncoderSetFrameName(
        frame_settings: *mut JxlEncoderFrameSettings,
        frame_name: *const ::std::os::raw::c_char,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Sets the bit depth of the input buffer.\n\n For float pixel formats, only the default JXL_BIT_DEPTH_FROM_PIXEL_FORMAT\n setting is allowed, while for unsigned pixel formats,\n JXL_BIT_DEPTH_FROM_CODESTREAM setting is also allowed. See the comment on\n @ref JxlEncoderAddImageFrame for the effects of the bit depth setting.\n\n @param frame_settings set of options and metadata for this frame. Also\n includes reference to the encoder object.\n @param bit_depth the bit depth setting of the pixel input\n @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error"]
    pub fn JxlEncoderSetFrameBitDepth(
        frame_settings: *mut JxlEncoderFrameSettings,
        bit_depth: *const JxlBitDepth,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Sets the buffer to read JPEG encoded bytes from for the next frame to encode.\n\n If JxlEncoderSetBasicInfo has not yet been called, calling\n JxlEncoderAddJPEGFrame will implicitly call it with the parameters of the\n added JPEG frame.\n\n If JxlEncoderSetColorEncoding or JxlEncoderSetICCProfile has not yet been\n called, calling JxlEncoderAddJPEGFrame will implicitly call it with the\n parameters of the added JPEG frame.\n\n If the encoder is set to store JPEG reconstruction metadata using @ref\n JxlEncoderStoreJPEGMetadata and a single JPEG frame is added, it will be\n possible to losslessly reconstruct the JPEG codestream.\n\n If this is the last frame, @ref JxlEncoderCloseInput or @ref\n JxlEncoderCloseFrames must be called before the next\n @ref JxlEncoderProcessOutput call.\n\n @param frame_settings set of options and metadata for this frame. Also\n includes reference to the encoder object.\n @param buffer bytes to read JPEG from. Owned by the caller and its contents\n are copied internally.\n @param size size of buffer in bytes.\n @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error"]
    pub fn JxlEncoderAddJPEGFrame(
        frame_settings: *const JxlEncoderFrameSettings,
        buffer: *const u8,
        size: usize,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Sets the buffer to read pixels from for the next image to encode. Must call\n JxlEncoderSetBasicInfo before JxlEncoderAddImageFrame.\n\n Currently only some data types for pixel formats are supported:\n - JXL_TYPE_UINT8, with range 0..255\n - JXL_TYPE_UINT16, with range 0..65535\n - JXL_TYPE_FLOAT16, with nominal range 0..1\n - JXL_TYPE_FLOAT, with nominal range 0..1\n\n Note: the sample data type in pixel_format is allowed to be different from\n what is described in the JxlBasicInfo. The type in pixel_format, together\n with an optional @ref JxlBitDepth parameter set by @ref\n JxlEncoderSetFrameBitDepth describes the format of the uncompressed pixel\n buffer. The bits_per_sample and exponent_bits_per_sample in the JxlBasicInfo\n describes what will actually be encoded in the JPEG XL codestream.\n For example, to encode a 12-bit image, you would set bits_per_sample to 12,\n while the input frame buffer can be in the following formats:\n  - if pixel format is in JXL_TYPE_UINT16 with default bit depth setting\n    (i.e. JXL_BIT_DEPTH_FROM_PIXEL_FORMAT), input sample values are rescaled\n    to 16-bit, i.e. multiplied by 65535/4095;\n  - if pixel format is in JXL_TYPE_UINT16 with JXL_BIT_DEPTH_FROM_CODESTREAM\n    bit depth setting, input sample values are provided unscaled;\n  - if pixel format is in JXL_TYPE_FLOAT, input sample values are rescaled\n    to 0..1, i.e.  multiplied by 1.f/4095.f.\n While it is allowed, it is obviously not recommended to use a pixel_format\n with lower precision than what is specified in the JxlBasicInfo.\n\n We support interleaved channels as described by the JxlPixelFormat:\n - single-channel data, e.g. grayscale\n - single-channel + alpha\n - trichromatic, e.g. RGB\n - trichromatic + alpha\n\n Extra channels not handled here need to be set by @ref\n JxlEncoderSetExtraChannelBuffer.\n If the image has alpha, and alpha is not passed here, it will implicitly be\n set to all-opaque (an alpha value of 1.0 everywhere).\n\n The pixels are assumed to be encoded in the original profile that is set with\n JxlEncoderSetColorEncoding or JxlEncoderSetICCProfile. If none of these\n functions were used, the pixels are assumed to be nonlinear sRGB for integer\n data types (JXL_TYPE_UINT8, JXL_TYPE_UINT16), and linear sRGB for floating\n point data types (JXL_TYPE_FLOAT16, JXL_TYPE_FLOAT).\n\n Sample values in floating-point pixel formats are allowed to be outside the\n nominal range, e.g. to represent out-of-sRGB-gamut colors in the\n uses_original_profile=false case. They are however not allowed to be NaN or\n +-infinity.\n\n If this is the last frame, @ref JxlEncoderCloseInput or @ref\n JxlEncoderCloseFrames must be called before the next\n @ref JxlEncoderProcessOutput call.\n\n @param frame_settings set of options and metadata for this frame. Also\n includes reference to the encoder object.\n @param pixel_format format for pixels. Object owned by the caller and its\n contents are copied internally.\n @param buffer buffer type to input the pixel data from. Owned by the caller\n and its contents are copied internally.\n @param size size of buffer in bytes. This size should match what is implied\n by the frame dimensions and the pixel format.\n @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error"]
    pub fn JxlEncoderAddImageFrame(
        frame_settings: *const JxlEncoderFrameSettings,
        pixel_format: *const JxlPixelFormat,
        buffer: *const ::std::os::raw::c_void,
        size: usize,
    ) -> JxlEncoderStatus;
}
#[doc = " The JxlEncoderOutputProcessor structure provides an interface for the\n encoder's output processing. Users of the library, who want to do streaming\n encoding, should implement the required callbacks for buffering, writing,\n seeking (if supported), and setting a finalized position during the encoding\n process.\n\n At a high level, the processor can be in one of two states:\n - With an active buffer: This indicates that a buffer has been acquired using\n   `get_buffer` and encoded data can be written to it.\n - Without an active buffer: In this state, no data can be written. A new\n buffer must be acquired after releasing any previously active buffer.\n\n The library will not acquire more than one buffer at a given time.\n\n The state of the processor includes `position` and `finalized position`,\n which have the following meaning.\n\n - position: Represents the current position, in bytes, within the output\n stream where the encoded data will be written next. This position moves\n forward with each `release_buffer` call as data is written, and can also be\n adjusted through the optional seek callback, if provided. At this position\n the next write will occur.\n\n - finalized position:  A position in the output stream that ensures all bytes\n before this point are finalized and won't be changed by later writes.\n\n All fields but `seek` are required, `seek` is optional and can be NULL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlEncoderOutputProcessor {
    #[doc = " Required.\n An opaque pointer that the client can use to store custom data.\n This data will be passed to the associated callback functions."]
    pub opaque: *mut ::std::os::raw::c_void,
    #[doc = " Required.\n Acquires a buffer at the current position into which the library will write\n the output data.\n\n If the `size` argument points to 0 and the returned value is NULL, this\n will be interpreted as asking the output writing to stop. In such a case,\n the library will return an error. The client is expected to set the size of\n the returned buffer based on the suggested `size` when this function is\n called.\n\n @param opaque user supplied parameters to the callback\n @param size points to a suggested buffer size when called; must be set to\n the size of the returned buffer once the function returns.\n @return a pointer to the acquired buffer or NULL to indicate a stop\n condition."]
    pub get_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            size: *mut usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Required.\n Notifies the user of library that the current buffer's data has been\n written and can be released. This function should advance the current\n position of the buffer by `written_bytes` number of bytes.\n\n @param opaque user supplied parameters to the callback\n @param written_bytes the number of bytes written to the buffer."]
    pub release_buffer: ::std::option::Option<
        unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, written_bytes: usize),
    >,
    #[doc = " Optional, can be NULL\n Seeks to a specific position in the output. This function is optional and\n can be set to NULL if the output doesn't support seeking. Can only be done\n when there is no buffer. Cannot be used to seek before the finalized\n position.\n\n @param opaque user supplied parameters to the callback\n @param position the position to seek to, in bytes."]
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, position: u64),
    >,
    #[doc = " Required.\n Sets a finalized position on the output data, at a specific position.\n Seeking will never request a position before the finalized position.\n\n Will only be called if there is no active buffer.\n\n @param opaque user supplied parameters to the callback\n @param finalized_position the position, in bytes, where the finalized\n position should be set."]
    pub set_finalized_position: ::std::option::Option<
        unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, finalized_position: u64),
    >,
}
#[test]
fn bindgen_test_layout_JxlEncoderOutputProcessor() {
    const UNINIT: ::std::mem::MaybeUninit<JxlEncoderOutputProcessor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JxlEncoderOutputProcessor>(),
        40usize,
        concat!("Size of: ", stringify!(JxlEncoderOutputProcessor))
    );
    assert_eq!(
        ::std::mem::align_of::<JxlEncoderOutputProcessor>(),
        8usize,
        concat!("Alignment of ", stringify!(JxlEncoderOutputProcessor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlEncoderOutputProcessor),
        "::",
        stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_buffer) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlEncoderOutputProcessor),
        "::",
        stringify!(get_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release_buffer) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlEncoderOutputProcessor),
        "::",
        stringify!(release_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlEncoderOutputProcessor),
        "::",
        stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_finalized_position) as usize - ptr as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlEncoderOutputProcessor),
        "::",
        stringify!(set_finalized_position)
        )
    );
}
extern "C" {
    #[doc = " Sets the output processor for the encoder. This processor determines how the\n encoder will handle buffering, writing, seeking (if supported), and\n setting a finalized position during the encoding process.\n\n This should not be used when using @ref JxlEncoderProcessOutput.\n\n @param enc encoder object.\n @param output_processor the struct containing the callbacks for managing\n output.\n @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error."]
    pub fn JxlEncoderSetOutputProcessor(
        enc: *mut JxlEncoder,
        output_processor: JxlEncoderOutputProcessor,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Flushes any buffered input in the encoder, ensuring that all available input\n data has been processed and written to the output.\n\n This function can only be used after @ref JxlEncoderSetOutputProcessor.\n Before making the last call to @ref JxlEncoderFlushInput, users should call\n @ref JxlEncoderCloseInput to signal the end of input data.\n\n This should not be used when using @ref JxlEncoderProcessOutput.\n\n @param enc encoder object.\n @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error."]
    pub fn JxlEncoderFlushInput(enc: *mut JxlEncoder) -> JxlEncoderStatus;
}
#[doc = " This struct provides callback functions to pass pixel data in a streaming\n manner instead of requiring the entire frame data in memory at once."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JxlChunkedFrameInputSource {
    #[doc = " A pointer to any user-defined data or state. This can be used to pass\n information to the callback functions."]
    pub opaque: *mut ::std::os::raw::c_void,
    #[doc = " Get the pixel format that color channel data will be provided in.\n When called, `pixel_format` points to a suggested pixel format; if\n color channel data can be given in this pixel format, processing might\n be more efficient.\n\n This function will be called exactly once, before any call to\n get_color_channel_at.\n\n @param opaque user supplied parameters to the callback\n @param pixel_format format for pixels"]
    pub get_color_channels_pixel_format: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            pixel_format: *mut JxlPixelFormat,
        ),
    >,
    #[doc = " Callback to retrieve a rectangle of color channel data at a specific\n location. It is guaranteed that xpos and ypos are multiples of 128. xsize,\n ysize will be multiples of 128, unless the resulting rectangle would be out\n of image bounds. Moreover, xsize and ysize will be at most 2048. The\n returned data will be assumed to be in the format returned by the\n (preceding) call to get_color_channels_pixel_format, except the `align`\n parameter of the pixel format will be ignored. Instead, the `i`-th row will\n be assumed to start at position `return_value + i * *row_offset`, with the\n value of `*row_offset` decided by the callee.\n\n Note that multiple calls to `get_color_channel_data_at` may happen before a\n call to `release_buffer`.\n\n @param opaque user supplied parameters to the callback\n @param xpos horizontal position for the data.\n @param ypos vertical position for the data.\n @param xsize horizontal size of the requested rectangle of data.\n @param ysize vertical size of the requested rectangle of data.\n @param row_offset pointer to a the byte offset between consecutive rows of\n the retrieved pixel data.\n @return pointer to the retrieved pixel data."]
    pub get_color_channel_data_at: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            xpos: usize,
            ypos: usize,
            xsize: usize,
            ysize: usize,
            row_offset: *mut usize,
        ) -> *const ::std::os::raw::c_void,
    >,
    #[doc = " Get the pixel format that extra channel data will be provided in.\n When called, `pixel_format` points to a suggested pixel format; if\n extra channel data can be given in this pixel format, processing might\n be more efficient.\n\n This function will be called exactly once per index, before any call to\n get_extra_channel_data_at with that given index.\n\n @param opaque user supplied parameters to the callback\n @param ec_index zero-indexed index of the extra channel\n @param pixel_format format for extra channel data"]
    pub get_extra_channel_pixel_format: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            ec_index: usize,
            pixel_format: *mut JxlPixelFormat,
        ),
    >,
    #[doc = " Callback to retrieve a rectangle of extra channel `ec_index` data at a\n specific location. It is guaranteed that xpos and ypos are multiples of\n 128. xsize, ysize will be multiples of 128, unless the resulting rectangle\n would be out of image bounds. Moreover, xsize and ysize will be at most\n 2048. The returned data will be assumed to be in the format returned by the\n (preceding) call to get_extra_channels_pixel_format_at with the\n corresponding extra channel index `ec_index`, except the `align` parameter\n of the pixel format will be ignored. Instead, the `i`-th row will be\n assumed to start at position `return_value + i * *row_offset`, with the\n value of `*row_offset` decided by the callee.\n\n Note that multiple calls to `get_extra_channel_data_at` may happen before a\n call to `release_buffer`.\n\n @param opaque user supplied parameters to the callback\n @param xpos horizontal position for the data.\n @param ypos vertical position for the data.\n @param xsize horizontal size of the requested rectangle of data.\n @param ysize vertical size of the requested rectangle of data.\n @param row_offset pointer to a the byte offset between consecutive rows of\n the retrieved pixel data.\n @return pointer to the retrieved pixel data."]
    pub get_extra_channel_data_at: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            ec_index: usize,
            xpos: usize,
            ypos: usize,
            xsize: usize,
            ysize: usize,
            row_offset: *mut usize,
        ) -> *const ::std::os::raw::c_void,
    >,
    #[doc = " Releases the buffer `buf` (obtained through a call to\n `get_color_channel_data_at` or `get_extra_channel_data_at`). This function\n will be called exactly once per call to `get_color_channel_data_at` or\n `get_extra_channel_data_at`.\n\n @param opaque user supplied parameters to the callback\n @param buf pointer returned by `get_color_channel_data_at` or\n `get_extra_channel_data_at`"]
    pub release_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            buf: *const ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_JxlChunkedFrameInputSource() {
    const UNINIT: ::std::mem::MaybeUninit<JxlChunkedFrameInputSource> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JxlChunkedFrameInputSource>(),
        48usize,
        concat!("Size of: ", stringify!(JxlChunkedFrameInputSource))
    );
    assert_eq!(
        ::std::mem::align_of::<JxlChunkedFrameInputSource>(),
        8usize,
        concat!("Alignment of ", stringify!(JxlChunkedFrameInputSource))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlChunkedFrameInputSource),
        "::",
        stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).get_color_channels_pixel_format) as usize - ptr as usize
        },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlChunkedFrameInputSource),
        "::",
        stringify!(get_color_channels_pixel_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_color_channel_data_at) as usize - ptr as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlChunkedFrameInputSource),
        "::",
        stringify!(get_color_channel_data_at)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).get_extra_channel_pixel_format) as usize - ptr as usize
        },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlChunkedFrameInputSource),
        "::",
        stringify!(get_extra_channel_pixel_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_extra_channel_data_at) as usize - ptr as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlChunkedFrameInputSource),
        "::",
        stringify!(get_extra_channel_data_at)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release_buffer) as usize - ptr as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(JxlChunkedFrameInputSource),
        "::",
        stringify!(release_buffer)
        )
    );
}
extern "C" {
    #[doc = " @brief Adds a frame to the encoder using a chunked input source.\n\n This function gives a way to encode a frame by providing pixel data in a\n chunked or streaming manner, which can be especially useful when dealing with\n large images that may not fit entirely in memory or when trying to optimize\n memory usage. The input data is provided through callbacks defined in the\n `JxlChunkedFrameInputSource` struct. Once the frame data has been completely\n retrieved, this function will flush the input and close it if it is the last\n frame.\n\n @param frame_settings set of options and metadata for this frame. Also\n includes reference to the encoder object.\n @param is_last_frame indicates if this is the last frame.\n @param chunked_frame_input struct providing callback methods for retrieving\n pixel data in chunks.\n\n @return Returns a status indicating the success or failure of adding the\n frame."]
    pub fn JxlEncoderAddChunkedFrame(
        frame_settings: *const JxlEncoderFrameSettings,
        is_last_frame: ::std::os::raw::c_int,
        chunked_frame_input: JxlChunkedFrameInputSource,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Sets the buffer to read pixels from for an extra channel at a given index.\n The index must be smaller than the num_extra_channels in the associated\n JxlBasicInfo. Must call @ref JxlEncoderSetExtraChannelInfo before\n JxlEncoderSetExtraChannelBuffer.\n\n TODO(firsching): mention what data types in pixel formats are supported.\n\n It is required to call this function for every extra channel, except for the\n alpha channel if that was already set through @ref JxlEncoderAddImageFrame.\n\n @param frame_settings set of options and metadata for this frame. Also\n includes reference to the encoder object.\n @param pixel_format format for pixels. Object owned by the caller and its\n contents are copied internally. The num_channels value is ignored, since the\n number of channels for an extra channel is always assumed to be one.\n @param buffer buffer type to input the pixel data from. Owned by the caller\n and its contents are copied internally.\n @param size size of buffer in bytes. This size should match what is implied\n by the frame dimensions and the pixel format.\n @param index index of the extra channel to use.\n @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error"]
    pub fn JxlEncoderSetExtraChannelBuffer(
        frame_settings: *const JxlEncoderFrameSettings,
        pixel_format: *const JxlPixelFormat,
        buffer: *const ::std::os::raw::c_void,
        size: usize,
        index: u32,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Adds a metadata box to the file format. JxlEncoderProcessOutput must be used\n to effectively write the box to the output. @ref JxlEncoderUseBoxes must\n be enabled before using this function.\n\n Boxes allow inserting application-specific data and metadata (Exif, XML/XMP,\n JUMBF and user defined boxes).\n\n The box format follows ISO BMFF and shares features and box types with other\n image and video formats, including the Exif, XML and JUMBF boxes. The box\n format for JPEG XL is specified in ISO/IEC 18181-2.\n\n Boxes in general don't contain other boxes inside, except a JUMBF superbox.\n Boxes follow each other sequentially and are byte-aligned. If the container\n format is used, the JXL stream consists of concatenated boxes.\n It is also possible to use a direct codestream without boxes, but in that\n case metadata cannot be added.\n\n Each box generally has the following byte structure in the file:\n - 4 bytes: box size including box header (Big endian. If set to 0, an\n   8-byte 64-bit size follows instead).\n - 4 bytes: type, e.g. \"JXL \" for the signature box, \"jxlc\" for a codestream\n   box.\n - N bytes: box contents.\n\n Only the box contents are provided to the contents argument of this function,\n the encoder encodes the size header itself. Most boxes are written\n automatically by the encoder as needed (\"JXL \", \"ftyp\", \"jxll\", \"jxlc\",\n \"jxlp\", \"jxli\", \"jbrd\"), and this function only needs to be called to add\n optional metadata when encoding from pixels (using JxlEncoderAddImageFrame).\n When recompressing JPEG files (using JxlEncoderAddJPEGFrame), if the input\n JPEG contains EXIF, XMP or JUMBF metadata, the corresponding boxes are\n already added automatically.\n\n Box types are given by 4 characters. The following boxes can be added with\n this function:\n - \"Exif\": a box with EXIF metadata, can be added by libjxl users, or is\n   automatically added when needed for JPEG reconstruction. The contents of\n   this box must be prepended by a 4-byte tiff header offset, which may\n   be 4 zero bytes in case the tiff header follows immediately.\n   The EXIF metadata must be in sync with what is encoded in the JPEG XL\n   codestream, specifically the image orientation. While this is not\n   recommended in practice, in case of conflicting metadata, the JPEG XL\n   codestream takes precedence.\n - \"xml \": a box with XML data, in particular XMP metadata, can be added by\n   libjxl users, or is automatically added when needed for JPEG reconstruction\n - \"jumb\": a JUMBF superbox, which can contain boxes with different types of\n   metadata inside. This box type can be added by the encoder transparently,\n   and other libraries to create and handle JUMBF content exist.\n - Application-specific boxes. Their typename should not begin with \"jxl\" or\n   \"JXL\" or conflict with other existing typenames, and they should be\n   registered with MP4RA (mp4ra.org).\n\n These boxes can be stored uncompressed or Brotli-compressed (using a \"brob\"\n box), depending on the compress_box parameter.\n\n @param enc encoder object.\n @param type the box type, e.g. \"Exif\" for EXIF metadata, \"xml \" for XMP or\n IPTC metadata, \"jumb\" for JUMBF metadata.\n @param contents the full contents of the box, for example EXIF\n data. ISO BMFF box header must not be included, only the contents. Owned by\n the caller and its contents are copied internally.\n @param size size of the box contents.\n @param compress_box Whether to compress this box as a \"brob\" box. Requires\n Brotli support.\n @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error, such as when\n using this function without JxlEncoderUseContainer, or adding a box type\n that would result in an invalid file format."]
    pub fn JxlEncoderAddBox(
        enc: *mut JxlEncoder,
        type_: *mut ::std::os::raw::c_char,
        contents: *const u8,
        size: usize,
        compress_box: ::std::os::raw::c_int,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Indicates the intention to add metadata boxes. This allows @ref\n JxlEncoderAddBox to be used. When using this function, then it is required\n to use @ref JxlEncoderCloseBoxes at the end.\n\n By default the encoder assumes no metadata boxes will be added.\n\n This setting can only be set at the beginning, before encoding starts.\n\n @param enc encoder object."]
    pub fn JxlEncoderUseBoxes(enc: *mut JxlEncoder) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Declares that no further boxes will be added with @ref JxlEncoderAddBox.\n This function must be called after the last box is added so the encoder knows\n the stream will be finished. It is not necessary to use this function if\n @ref JxlEncoderUseBoxes is not used. Further frames may still be added.\n\n Must be called between JxlEncoderAddBox of the last box\n and the next call to JxlEncoderProcessOutput, or @ref JxlEncoderProcessOutput\n won't output the last box correctly.\n\n NOTE: if you don't need to close frames and boxes at separate times, you can\n use @ref JxlEncoderCloseInput instead to close both at once.\n\n @param enc encoder object."]
    pub fn JxlEncoderCloseBoxes(enc: *mut JxlEncoder);
}
extern "C" {
    #[doc = " Declares that no frames will be added and @ref JxlEncoderAddImageFrame and\n @ref JxlEncoderAddJPEGFrame won't be called anymore. Further metadata boxes\n may still be added. This function or @ref JxlEncoderCloseInput must be called\n after adding the last frame and the next call to\n @ref JxlEncoderProcessOutput, or the frame won't be properly marked as last.\n\n NOTE: if you don't need to close frames and boxes at separate times, you can\n use @ref JxlEncoderCloseInput instead to close both at once.\n\n @param enc encoder object."]
    pub fn JxlEncoderCloseFrames(enc: *mut JxlEncoder);
}
extern "C" {
    #[doc = " Closes any input to the encoder, equivalent to calling JxlEncoderCloseFrames\n as well as calling JxlEncoderCloseBoxes if needed. No further input of any\n kind may be given to the encoder, but further @ref JxlEncoderProcessOutput\n calls should be done to create the final output.\n\n The requirements of both @ref JxlEncoderCloseFrames and @ref\n JxlEncoderCloseBoxes apply to this function. Either this function or the\n other two must be called after the final frame and/or box, and the next\n @ref JxlEncoderProcessOutput call, or the codestream won't be encoded\n correctly.\n\n @param enc encoder object."]
    pub fn JxlEncoderCloseInput(enc: *mut JxlEncoder);
}
extern "C" {
    #[doc = " Sets the original color encoding of the image encoded by this encoder. This\n is an alternative to JxlEncoderSetICCProfile and only one of these two must\n be used. This one sets the color encoding as a @ref JxlColorEncoding, while\n the other sets it as ICC binary data.\n Must be called after JxlEncoderSetBasicInfo.\n\n @param enc encoder object.\n @param color color encoding. Object owned by the caller and its contents are\n copied internally.\n @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR or\n JXL_ENC_NOT_SUPPORTED otherwise"]
    pub fn JxlEncoderSetColorEncoding(
        enc: *mut JxlEncoder,
        color: *const JxlColorEncoding,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Sets the original color encoding of the image encoded by this encoder as an\n ICC color profile. This is an alternative to JxlEncoderSetColorEncoding and\n only one of these two must be used. This one sets the color encoding as ICC\n binary data, while the other defines it as a @ref JxlColorEncoding.\n Must be called after JxlEncoderSetBasicInfo.\n\n @param enc encoder object.\n @param icc_profile bytes of the original ICC profile\n @param size size of the icc_profile buffer in bytes\n @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR or\n JXL_ENC_NOT_SUPPORTED otherwise"]
    pub fn JxlEncoderSetICCProfile(
        enc: *mut JxlEncoder,
        icc_profile: *const u8,
        size: usize,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Initializes a JxlBasicInfo struct to default values.\n For forwards-compatibility, this function has to be called before values\n are assigned to the struct fields.\n The default values correspond to an 8-bit RGB image, no alpha or any\n other extra channels.\n\n @param info global image metadata. Object owned by the caller."]
    pub fn JxlEncoderInitBasicInfo(info: *mut JxlBasicInfo);
}
extern "C" {
    #[doc = " Initializes a JxlFrameHeader struct to default values.\n For forwards-compatibility, this function has to be called before values\n are assigned to the struct fields.\n The default values correspond to a frame with no animation duration and the\n 'replace' blend mode. After using this function, For animation duration must\n be set, for composite still blend settings must be set.\n\n @param frame_header frame metadata. Object owned by the caller."]
    pub fn JxlEncoderInitFrameHeader(frame_header: *mut JxlFrameHeader);
}
extern "C" {
    #[doc = " Initializes a JxlBlendInfo struct to default values.\n For forwards-compatibility, this function has to be called before values\n are assigned to the struct fields.\n\n @param blend_info blending info. Object owned by the caller."]
    pub fn JxlEncoderInitBlendInfo(blend_info: *mut JxlBlendInfo);
}
extern "C" {
    #[doc = " Sets the global metadata of the image encoded by this encoder.\n\n If the JxlBasicInfo contains information of extra channels beyond an alpha\n channel, then @ref JxlEncoderSetExtraChannelInfo must be called between\n JxlEncoderSetBasicInfo and @ref JxlEncoderAddImageFrame. In order to indicate\n extra channels, the value of `info.num_extra_channels` should be set to the\n number of extra channels, also counting the alpha channel if present.\n\n @param enc encoder object.\n @param info global image metadata. Object owned by the caller and its\n contents are copied internally.\n @return JXL_ENC_SUCCESS if the operation was successful,\n JXL_ENC_ERROR or JXL_ENC_NOT_SUPPORTED otherwise"]
    pub fn JxlEncoderSetBasicInfo(
        enc: *mut JxlEncoder,
        info: *const JxlBasicInfo,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Sets the upsampling method the decoder will use in case there are frames\n with JXL_ENC_FRAME_SETTING_RESAMPLING set. This is useful in combination\n with the JXL_ENC_FRAME_SETTING_ALREADY_DOWNSAMPLED option, to control the\n type of upsampling that will be used.\n\n @param enc encoder object.\n @param factor upsampling factor to configure (1, 2, 4 or 8; for 1 this\n function has no effect at all)\n @param mode upsampling mode to use for this upsampling:\n -1: default (good for photographic images, no signaling overhead)\n 0: nearest neighbor (good for pixel art)\n 1: 'pixel dots' (same as NN for 2x, diamond-shaped 'pixel dots' for 4x/8x)\n @return JXL_ENC_SUCCESS if the operation was successful,\n JXL_ENC_ERROR or JXL_ENC_NOT_SUPPORTED otherwise"]
    pub fn JxlEncoderSetUpsamplingMode(
        enc: *mut JxlEncoder,
        factor: i64,
        mode: i64,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Initializes a JxlExtraChannelInfo struct to default values.\n For forwards-compatibility, this function has to be called before values\n are assigned to the struct fields.\n The default values correspond to an 8-bit channel of the provided type.\n\n @param type type of the extra channel.\n @param info global extra channel metadata. Object owned by the caller and its\n contents are copied internally."]
    pub fn JxlEncoderInitExtraChannelInfo(
        type_: JxlExtraChannelType,
        info: *mut JxlExtraChannelInfo,
    );
}
extern "C" {
    #[doc = " Sets information for the extra channel at the given index. The index\n must be smaller than num_extra_channels in the associated JxlBasicInfo.\n\n @param enc encoder object\n @param index index of the extra channel to set.\n @param info global extra channel metadata. Object owned by the caller and its\n contents are copied internally.\n @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error"]
    pub fn JxlEncoderSetExtraChannelInfo(
        enc: *mut JxlEncoder,
        index: usize,
        info: *const JxlExtraChannelInfo,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Sets the name for the extra channel at the given index in UTF-8. The index\n must be smaller than the num_extra_channels in the associated JxlBasicInfo.\n\n TODO(lode): remove size parameter for consistency with\n JxlEncoderSetFrameName\n\n @param enc encoder object\n @param index index of the extra channel to set.\n @param name buffer with the name of the extra channel.\n @param size size of the name buffer in bytes, not counting the terminating\n character.\n @return JXL_ENC_SUCCESS on success, JXL_ENC_ERROR on error"]
    pub fn JxlEncoderSetExtraChannelName(
        enc: *mut JxlEncoder,
        index: usize,
        name: *const ::std::os::raw::c_char,
        size: usize,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Sets a frame-specific option of integer type to the encoder options.\n The JxlEncoderFrameSettingId argument determines which option is set.\n\n @param frame_settings set of options and metadata for this frame. Also\n includes reference to the encoder object.\n @param option ID of the option to set.\n @param value Integer value to set for this option.\n @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR in\n case of an error, such as invalid or unknown option id, or invalid integer\n value for the given option. If an error is returned, the state of the\n JxlEncoderFrameSettings object is still valid and is the same as before this\n function was called."]
    pub fn JxlEncoderFrameSettingsSetOption(
        frame_settings: *mut JxlEncoderFrameSettings,
        option: JxlEncoderFrameSettingId,
        value: i64,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Sets a frame-specific option of float type to the encoder options.\n The JxlEncoderFrameSettingId argument determines which option is set.\n\n @param frame_settings set of options and metadata for this frame. Also\n includes reference to the encoder object.\n @param option ID of the option to set.\n @param value Float value to set for this option.\n @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR in\n case of an error, such as invalid or unknown option id, or invalid integer\n value for the given option. If an error is returned, the state of the\n JxlEncoderFrameSettings object is still valid and is the same as before this\n function was called."]
    pub fn JxlEncoderFrameSettingsSetFloatOption(
        frame_settings: *mut JxlEncoderFrameSettings,
        option: JxlEncoderFrameSettingId,
        value: f32,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Forces the encoder to use the box-based container format (BMFF) even\n when not necessary.\n\n When using @ref JxlEncoderUseBoxes, @ref JxlEncoderStoreJPEGMetadata or @ref\n JxlEncoderSetCodestreamLevel with level 10, the encoder will automatically\n also use the container format, it is not necessary to use\n JxlEncoderUseContainer for those use cases.\n\n By default this setting is disabled.\n\n This setting can only be set at the beginning, before encoding starts.\n\n @param enc encoder object.\n @param use_container true if the encoder should always output the JPEG XL\n container format, false to only output it when necessary.\n @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR\n otherwise."]
    pub fn JxlEncoderUseContainer(
        enc: *mut JxlEncoder,
        use_container: ::std::os::raw::c_int,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Configure the encoder to store JPEG reconstruction metadata in the JPEG XL\n container.\n\n If this is set to true and a single JPEG frame is added, it will be\n possible to losslessly reconstruct the JPEG codestream.\n\n This setting can only be set at the beginning, before encoding starts.\n\n @param enc encoder object.\n @param store_jpeg_metadata true if the encoder should store JPEG metadata.\n @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR\n otherwise."]
    pub fn JxlEncoderStoreJPEGMetadata(
        enc: *mut JxlEncoder,
        store_jpeg_metadata: ::std::os::raw::c_int,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Sets the feature level of the JPEG XL codestream. Valid values are 5 and\n 10, or -1 (to choose automatically). Using the minimum required level, or\n level 5 in most cases, is recommended for compatibility with all decoders.\n\n Level 5: for end-user image delivery, this level is the most widely\n supported level by image decoders and the recommended level to use unless a\n level 10 feature is absolutely necessary. Supports a maximum resolution\n 268435456 pixels total with a maximum width or height of 262144 pixels,\n maximum 16-bit color channel depth, maximum 120 frames per second for\n animation, maximum ICC color profile size of 4 MiB, it allows all color\n models and extra channel types except CMYK and the JXL_CHANNEL_BLACK extra\n channel, and a maximum of 4 extra channels in addition to the 3 color\n channels. It also sets boundaries to certain internally used coding tools.\n\n Level 10: this level removes or increases the bounds of most of the level\n 5 limitations, allows CMYK color and up to 32 bits per color channel, but\n may be less widely supported.\n\n The default value is -1. This means the encoder will automatically choose\n between level 5 and level 10 based on what information is inside the @ref\n JxlBasicInfo structure. Do note that some level 10 features, particularly\n those used by animated JPEG XL codestreams, might require level 10, even\n though the @ref JxlBasicInfo only suggests level 5. In this case, the level\n must be explicitly set to 10, otherwise the encoder will return an error.\n The encoder will restrict internal encoding choices to those compatible with\n the level setting.\n\n This setting can only be set at the beginning, before encoding starts.\n\n @param enc encoder object.\n @param level the level value to set, must be -1, 5, or 10.\n @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR\n otherwise."]
    pub fn JxlEncoderSetCodestreamLevel(
        enc: *mut JxlEncoder,
        level: ::std::os::raw::c_int,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Returns the codestream level required to support the currently configured\n settings and basic info. This function can only be used at the beginning,\n before encoding starts, but after setting basic info.\n\n This does not support per-frame settings, only global configuration, such as\n the image dimensions, that are known at the time of writing the header of\n the JPEG XL file.\n\n If this returns 5, nothing needs to be done and the codestream can be\n compatible with any decoder. If this returns 10, JxlEncoderSetCodestreamLevel\n has to be used to set the codestream level to 10, or the encoder can be\n configured differently to allow using the more compatible level 5.\n\n @param enc encoder object.\n @return -1 if no level can support the configuration (e.g. image dimensions\n larger than even level 10 supports), 5 if level 5 is supported, 10 if setting\n the codestream level to 10 is required.\n"]
    pub fn JxlEncoderGetRequiredCodestreamLevel(enc: *const JxlEncoder) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enables lossless encoding.\n\n This is not an option like the others on itself, but rather while enabled it\n overrides a set of existing options (such as distance, modular mode and\n color transform) that enables bit-for-bit lossless encoding.\n\n When disabled, those options are not overridden, but since those options\n could still have been manually set to a combination that operates losslessly,\n using this function with lossless set to JXL_DEC_FALSE does not guarantee\n lossy encoding, though the default set of options is lossy.\n\n @param frame_settings set of options and metadata for this frame. Also\n includes reference to the encoder object.\n @param lossless whether to override options for lossless mode\n @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR\n otherwise."]
    pub fn JxlEncoderSetFrameLossless(
        frame_settings: *mut JxlEncoderFrameSettings,
        lossless: ::std::os::raw::c_int,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Sets the distance level for lossy compression: target max butteraugli\n distance, lower = higher quality. Range: 0 .. 25.\n 0.0 = mathematically lossless (however, use JxlEncoderSetFrameLossless\n instead to use true lossless, as setting distance to 0 alone is not the only\n requirement). 1.0 = visually lossless. Recommended range: 0.5 .. 3.0. Default\n value: 1.0.\n\n @param frame_settings set of options and metadata for this frame. Also\n includes reference to the encoder object.\n @param distance the distance value to set.\n @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR\n otherwise."]
    pub fn JxlEncoderSetFrameDistance(
        frame_settings: *mut JxlEncoderFrameSettings,
        distance: f32,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Sets the distance level for lossy compression of extra channels.\n The distance is as in JxlEncoderSetFrameDistance (lower = higher quality).\n If not set, or if set to the special value -1, the distance that was set with\n JxlEncoderSetFrameDistance will be used.\n\n @param frame_settings set of options and metadata for this frame. Also\n includes reference to the encoder object.\n @param index index of the extra channel to set a distance value for.\n @param distance the distance value to set.\n @return JXL_ENC_SUCCESS if the operation was successful, JXL_ENC_ERROR\n otherwise."]
    pub fn JxlEncoderSetExtraChannelDistance(
        frame_settings: *mut JxlEncoderFrameSettings,
        index: usize,
        distance: f32,
    ) -> JxlEncoderStatus;
}
extern "C" {
    #[doc = " Maps JPEG-style quality factor to distance.\n\n This function takes in input a JPEG-style quality factor `quality` and\n produces as output a `distance` value suitable to be used with @ref\n JxlEncoderSetFrameDistance and\n @ref JxlEncoderSetExtraChannelDistance.\n\n The `distance` value influences the level of compression, with lower values\n indicating higher quality:\n - 0.0 implies lossless compression (however, note that calling @ref\n JxlEncoderSetFrameLossless is required).\n - 1.0 represents a visually lossy compression, which is also the default\n setting.\n\n The `quality` parameter, ranging up to 100, is inversely related to\n 'distance':\n - A `quality` of 100.0 maps to a `distance` of 0.0 (lossless).\n - A `quality` of 90.0 corresponds to a `distance` of 1.0.\n\n Recommended Range:\n - `distance`: 0.5 to 3.0.\n - corresponding `quality`: approximately 96 to 68.\n\n Allowed Range:\n - `distance`: 0.0 to 25.0.\n - corresponding `quality`: 100.0 to 0.0.\n\n Note: the `quality` parameter has no consistent psychovisual meaning\n across different codecs and libraries. Using the mapping defined by @ref\n JxlEncoderDistanceFromQuality will result in a visual quality roughly\n equivalent to what would be obtained with `libjpeg-turbo` with the same\n `quality` parameter, but that is by no means guaranteed; do not assume that\n the same quality value will result in similar file sizes and image quality\n across different codecs."]
    pub fn JxlEncoderDistanceFromQuality(quality: f32) -> f32;
}
extern "C" {
    #[doc = " Create a new set of encoder options, with all values initially copied from\n the @p source options, or set to default if @p source is NULL.\n\n The returned pointer is an opaque struct tied to the encoder and it will be\n deallocated by the encoder when JxlEncoderDestroy() is called. For functions\n taking both a @ref JxlEncoder and a @ref JxlEncoderFrameSettings, only\n JxlEncoderFrameSettings created with this function for the same encoder\n instance can be used.\n\n @param enc encoder object.\n @param source source options to copy initial values from, or NULL to get\n defaults initialized to defaults.\n @return the opaque struct pointer identifying a new set of encoder options."]
    pub fn JxlEncoderFrameSettingsCreate(
        enc: *mut JxlEncoder,
        source: *const JxlEncoderFrameSettings,
    ) -> *mut JxlEncoderFrameSettings;
}
extern "C" {
    #[doc = " Sets a color encoding to be sRGB.\n\n @param color_encoding color encoding instance.\n @param is_gray whether the color encoding should be gray scale or color."]
    pub fn JxlColorEncodingSetToSRGB(
        color_encoding: *mut JxlColorEncoding,
        is_gray: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Sets a color encoding to be linear sRGB.\n\n @param color_encoding color encoding instance.\n @param is_gray whether the color encoding should be gray scale or color."]
    pub fn JxlColorEncodingSetToLinearSRGB(
        color_encoding: *mut JxlColorEncoding,
        is_gray: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Enables usage of expert options.\n\n At the moment, the only expert option is setting an effort value of 10,\n which gives the best compression for pixel-lossless modes but is very slow.\n\n @param enc encoder object."]
    pub fn JxlEncoderAllowExpertOptions(enc: *mut JxlEncoder);
}
#[doc = " Function type for @ref JxlEncoderSetDebugImageCallback.\n\n The callback may be called simultaneously by different threads when using a\n threaded parallel runner, on different debug images.\n\n @param opaque optional user data, as given to @ref\n   JxlEncoderSetDebugImageCallback.\n @param label label of debug image, can be used in filenames\n @param xsize width of debug image\n @param ysize height of debug image\n @param color color encoding of debug image\n @param pixels pixel data of debug image as big-endian 16-bit unsigned\n   samples. The memory is not owned by the user, and is only valid during the\n   time the callback is running."]
pub type JxlDebugImageCallback = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::std::os::raw::c_void,
        label: *const ::std::os::raw::c_char,
        xsize: usize,
        ysize: usize,
        color: *const JxlColorEncoding,
        pixels: *const u16,
    ),
>;
extern "C" {
    #[doc = " Sets the given debug image callback that will be used by the encoder to\n output various debug images during encoding.\n\n This only has any effect if the encoder was compiled with the appropriate\n debug build flags.\n\n @param frame_settings set of options and metadata for this frame. Also\n includes reference to the encoder object.\n @param callback used to return the debug image\n @param opaque user supplied parameter to the image callback"]
    pub fn JxlEncoderSetDebugImageCallback(
        frame_settings: *mut JxlEncoderFrameSettings,
        callback: JxlDebugImageCallback,
        opaque: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Sets the given stats object for gathering various statistics during encoding.\n\n This only has any effect if the encoder was compiled with the appropriate\n debug build flags.\n\n @param frame_settings set of options and metadata for this frame. Also\n includes reference to the encoder object.\n @param stats object that can be used to query the gathered stats (created\n   by @ref JxlEncoderStatsCreate)"]
    pub fn JxlEncoderCollectStats(
        frame_settings: *mut JxlEncoderFrameSettings,
        stats: *mut JxlEncoderStats,
    );
}
extern "C" {
    pub fn _calloc_base(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        _Count: ::std::os::raw::c_ulonglong,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _callnewh(_Size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _expand(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _free_base(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _malloc_base(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize_base(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _msize(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _realloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_msize(
        _Block: *mut ::std::os::raw::c_void,
        _Alignment: usize,
        _Offset: usize,
    ) -> usize;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
pub type _CoreCrtSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type _CoreCrtNonSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    );
}
extern "C" {
    pub fn _lfind_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _itow_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itow(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ltow_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ultow_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstod(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstod_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstol(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoll(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoll_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoul(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoull(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoull_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstold(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstold_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstof(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn _wcstof_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn _wtof(_String: *const wchar_t) -> f64;
}
extern "C" {
    pub fn _wtof_l(_String: *const wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_String: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_String: *const wchar_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtoll(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoll_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _i64tow_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64tow(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ui64tow_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtoi64(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wfullpath(
        _Buffer: *mut wchar_t,
        _Path: *const wchar_t,
        _BufferCount: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wmakepath_s(
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath(
        _Buffer: *mut wchar_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    );
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const wchar_t);
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _Dir: *mut wchar_t,
        _Filename: *mut wchar_t,
        _Ext: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _DriveCount: usize,
        _Dir: *mut wchar_t,
        _DirCount: usize,
        _Filename: *mut wchar_t,
        _FilenameCount: usize,
        _Ext: *mut wchar_t,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(
        _Buffer: *mut *mut wchar_t,
        _BufferCount: *mut usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wgetenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv(_EnvString: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const wchar_t, _Value: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _ResultPath: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsystem(_Command: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn _set_abort_behavior(
        _Flags: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
    pub fn _set_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_thread_local_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_thread_local_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn __sys_errlist() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __sys_nerr() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrMsg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __p__pgmptr() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wpgmptr() -> *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut wchar_t) -> errno_t;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
    const UNINIT: ::std::mem::MaybeUninit<_div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_div_t),
        "::",
        stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(_div_t),
        "::",
        stringify!(rem)
        )
    );
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_ldiv_t),
        "::",
        stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(_ldiv_t),
        "::",
        stringify!(rem)
        )
    );
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_lldiv_t),
        "::",
        stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(_lldiv_t),
        "::",
        stringify!(rem)
        )
    );
}
pub type lldiv_t = _lldiv_t;
extern "C" {
    pub fn abs(_Number: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_Number: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _abs64(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _byteswap_ushort(_Number: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Number: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Number: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long)
                -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        _Numerator: ::std::os::raw::c_longlong,
        _Denominator: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn _rotl(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotl(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotl64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotr(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotr64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDOUBLE>(),
        10usize,
        concat!("Size of: ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDOUBLE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_LDOUBLE),
        "::",
        stringify!(ld)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_DOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_CRT_DOUBLE),
        "::",
        stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_FLOAT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Size of: ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_CRT_FLOAT),
        "::",
        stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LONGDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_LONGDOUBLE),
        "::",
        stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
    const UNINIT: ::std::mem::MaybeUninit<_LDBL12> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDBL12>(),
        12usize,
        concat!("Size of: ", stringify!(_LDBL12))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDBL12>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDBL12))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld12) as usize - ptr as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_LDBL12),
        "::",
        stringify!(ld12)
        )
    );
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _atoi_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atol_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atoll_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoflt(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtof(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn _strtof_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtold_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _itoa_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ltoa_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ultoa_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_String: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _mbstrlen_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _mbstrnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstrnlen_l(
        _String: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb_s(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _fullpath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _makepath_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveCount: usize,
        _Dir: *mut ::std::os::raw::c_char,
        _DirCount: usize,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameCount: usize,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn getenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn __p___argc() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p___wargv() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__environ() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wenviron() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _dupenv_s(
        _Buffer: *mut *mut ::std::os::raw::c_char,
        _BufferCount: *mut usize,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_s(
        _Name: *const ::std::os::raw::c_char,
        _Value: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    #[doc = " Parallel runner internally using std::thread. Use as JxlParallelRunner."]
    pub fn JxlThreadParallelRunner(
        runner_opaque: *mut ::std::os::raw::c_void,
        jpegxl_opaque: *mut ::std::os::raw::c_void,
        init: JxlParallelRunInit,
        func: JxlParallelRunFunction,
        start_range: u32,
        end_range: u32,
    ) -> JxlParallelRetCode;
}
extern "C" {
    #[doc = " Creates the runner for JxlThreadParallelRunner. Use as the opaque\n runner."]
    pub fn JxlThreadParallelRunnerCreate(
        memory_manager: *const JxlMemoryManager,
        num_worker_threads: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Destroys the runner created by JxlThreadParallelRunnerCreate."]
    pub fn JxlThreadParallelRunnerDestroy(runner_opaque: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Returns a default num_worker_threads value for\n JxlThreadParallelRunnerCreate."]
    pub fn JxlThreadParallelRunnerDefaultNumWorkerThreads() -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}

use std::io::{Seek, SeekFrom, Write};
use std::os::raw::c_void;
use std::ptr::null;
use thiserror::Error;

#[derive(Error,Debug)]
pub enum Error {
    #[error("JxlEncoder{} failed",0)]
    JxlEncoder(String),
}

struct LibJxlEncoder {

}

impl LibJxlEncoder {
    pub unsafe fn encode(mut output: Box<dyn WriteAndSeek>) -> Result<(), Error> {
        let num_worker_threads = JxlThreadParallelRunnerDefaultNumWorkerThreads();
        let runner_opaque = JxlThreadParallelRunnerCreate(null(), num_worker_threads);
        let runner: JxlParallelRunner = None;

        let encoder = JxlEncoderCreate(null());
        if JxlEncoderSetParallelRunner(encoder, runner, runner_opaque)
            != JxlEncoderStatus_JXL_ENC_SUCCESS {
            return Err(Error::JxlEncoder("SetParallelRunner".to_string()));
        }

        let stream_start = output.stream_position().unwrap();
        let output_box = Box::new( OutputProcessorStruct {
            stream: output,
            stream_start,
            buffer: None,
        });
        let output_processor = JxlEncoderOutputProcessor {
            opaque: Box::into_raw(output_box) as *mut c_void,
            get_buffer: Some(outputGetBuffer),
            release_buffer: None,
            seek: None,
            set_finalized_position: None,
        };
        if JxlEncoderSetOutputProcessor(encoder, output_processor)
            != JxlEncoderStatus_JXL_ENC_SUCCESS {
            return Err(Error::JxlEncoder("SetOutputProcessor".to_string()));
        }

        //destroy encoder
        //destroy runner_opaque
        //Box::from_raw(output_processor.opaque)

        Ok(())
    }
}

trait WriteAndSeek: Write + Seek {}
impl<T: Write+Seek> WriteAndSeek for T {}

struct OutputProcessorStruct
{
    stream: Box<dyn WriteAndSeek>,
    stream_start: u64,
    buffer: Option<Vec<u8>>,
}

unsafe extern "C" fn outputGetBuffer
    (opaque: *mut c_void, size: *mut usize) -> *mut c_void {
    let s = &mut *(opaque as *mut OutputProcessorStruct);
    let req_size = (*size).clone();

    if s.buffer.is_none() {
        s.buffer = Some(vec![0; req_size]);
    }
    let b = s.buffer.as_mut().unwrap();
    if b.capacity() < req_size {
        b.resize(req_size, 0);
    }

    *size = b.capacity();

    b.as_mut_ptr() as *mut c_void
}

unsafe extern "C" fn outputReleaseBuffer
    (opaque: *mut c_void, written_bytes: usize) {
    let s = &mut *(opaque as *mut OutputProcessorStruct);
    let b = s.buffer.as_ref().unwrap();

    s.stream.write_all(&b[0..written_bytes] ).expect("Writing JXL output failed");
}

unsafe extern "C" fn outputSeek(opaque: *mut c_void, position: u64) {
    let s = &mut *(opaque as *mut OutputProcessorStruct);
    s.stream.seek(SeekFrom::Start(&s.stream_start + position)).expect("Seeking JXL output failed");
}